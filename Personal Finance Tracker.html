<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Personal Finance Tracker</title>

  <!-- Your original inline styles -->  <style>
    /* Global Reset and Base Styles */
    * { box-sizing: border-box; }
    body {
      background: #0D0B14;
      color: #E0E0E0;
      font-family: "Poppins", sans-serif;
      margin: 0;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Reusable Card Component */
    .card, .app-container {
      background: #1A1625;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      margin-bottom: 24px;
    }
    .app-container {
      width: 100%;
      max-width: 1000px;
      padding: 25px;
      margin-top: 70px;
    }    /* Content Layout */
    .content {
      width: 100%;
      max-width: 1400px;
      margin-top: 70px;
      margin-left: auto;
      margin-right: auto;
    }
    
    /* Chart Containers */
    .chart-container, .category-chart-container, .net-worth-container, .recent-transactions-container {
      position: relative;
    }
    .chart-container > h2, .category-chart-container h2, .net-worth-container h2, .recent-transactions-container h2 {
      text-align: center;
      color: #63FFDA;
      font-weight: 600;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    .category-chart-inner-container, .net-worth-chart-inner-container, .charges-payments-chart-inner-container {
      position: relative;
      height: 300px;
    }
    .net-worth-chart-inner-container {
      height: 250px;
    }
    .charges-payments-chart-inner-container {
      height: 350px;
    }    /* Page Elements */
    h1 {
      color: #FFF;
      font-weight: 600;
      margin-bottom: 20px;
      text-align: center;
    }
    
    #total {
      text-align: center;
      font-size: 1.1em;
      color: #FFF;
    }
    
    /* Form Elements */
    #csvPicker, #categoryMonthSelector {
      display: block;
      margin: 0 auto 20px auto;
      padding: 10px;
      border: 1px solid #4F4B68;
      border-radius: 4px;
      background: #211D30;
      color: #E0E0E0;
      cursor: pointer;
    }
    #csvPicker::file-selector-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #63FFDA;
      color: #0D0B14;
      font-weight: 600;
      cursor: pointer;
      margin-right: 10px;
    }
    #categoryMonthSelector {
      margin: 15px auto 10px auto;
      padding: 8px;
    }

    /* Sidebar Navigation */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 60px;
      background: #1A1625;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 20px;
    }
    .sidebar a {
      color: #63FFDA;
            font-size: 24px;
      margin: 16px 0;
      text-decoration: none;
    }
    .sidebar a svg {
      width: 24px;
      height: 24px;
      fill: none;
      stroke: #63FFDA;
      stroke-width: 2;
    }
    
    /* Tab Components - Consolidated styling for File History and Banks tabs */
    .file-history-tab, .banks-tab {
      position: absolute;
      top: 18px;
      background: #211D30;
      color: #63FFDA;
      border: none;
      border-radius: 8px 8px 0 0;
      padding: 8px 22px 8px 18px;
      font-family: 'Poppins', sans-serif;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      transition: background 0.15s, color 0.15s;
    }
    .file-history-tab {
      left: 70px;
    }
    .banks-tab {
      left: 200px;
    }
    .file-history-tab.active, .banks-tab.active {
      background: #63FFDA;
      color: #0D0B14;
    }
    
    /* Panel Components - Consolidated styling for both panels */
    .file-history-panel {
      position: absolute;
      top: 54px;
      left: 70px;
      background: #1A1625;
      color: #E0E0E0;
      border-radius: 0 0 12px 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      min-width: 320px;
      max-width: 420px;
      padding: 18px 18px 10px 18px;
      z-index: 1100;
      display: none;
    }
    .file-history-panel h3 {
      margin: 0 0 10px 0;
      font-size: 1.1em;
      color: #63FFDA;
      font-weight: 600;
    }    /* List Components */
    .file-history-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 220px;
      overflow-y: auto;
    }
    .file-history-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 7px 0;
      border-bottom: 1px solid #29223a;
      font-size: 14px;
    }
    .file-history-list li:last-child { 
      border-bottom: none; 
    }
    .file-history-list .filename {
      flex: 1;
      color: #E0E0E0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .file-history-list .delete-btn {
      background: none;
      border: none;
      color: #FF6B6B;
      font-size: 15px;
      cursor: pointer;
      margin-left: 12px;
      padding: 2px 8px;
      border-radius: 4px;
      transition: background 0.15s;
    }
    .file-history-list .delete-btn:hover {
      background: #2a263a;
    }    /* Timeframe Controls - Consolidated */
    .timeframe-controls {
      text-align: center;
      margin-bottom: 15px;
      display: flex;
      justify-content: center;
      gap: 12px;
    }
    .timeframe-controls button {
      background: none;
      border: 1px solid transparent;
      color: #63FFDA;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      padding: 5px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s;
    }
    .timeframe-controls button.active {
      background-color: #0D0B14;
      color: #63FFDA;
      border-color: #63FFDA;
      box-shadow: none;
    }
    .timeframe-controls button:hover:not(.active) {
      background-color: transparent;
      color: #63FFDA;
      border-color: transparent;
      box-shadow: 0 0 8px #63FFDA;
    }    /* Layout Components */
    .charts-row-container {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 24px;
      margin-bottom: 24px;
    }
    .charts-row-container > .card {
      flex: 1 1 calc(50% - 12px);
      min-width: 300px;
      margin-bottom: 0;
    }
    
    /* Recent Transactions Table */
    .recent-transactions-table-container {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #29223a;
      border-radius: 8px;
    }
    .recent-transactions-table {
      width: 100%;
      border-collapse: collapse;
    }
    .recent-transactions-table th,
    .recent-transactions-table td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid #29223a;
    }
    .recent-transactions-table th {
      background-color: #211D30;
      color: #E0E0E0;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .recent-transactions-table td {
      color: #C0C0C0;
    }
    .recent-transactions-table tr:last-child td {
      border-bottom: none;
    }
    .recent-transactions-table .amount-income {
      color: #63FFDA;
      font-weight: 500;
    }
    .recent-transactions-table .amount-expense {
      color: #FF6B6B;
      font-weight: 500;
    }    /* Light Mode Overrides */
    body.light-mode .recent-transactions-container h2 {
      color: #00796b;
    }
    body.light-mode .recent-transactions-table-container {
      border: 1px solid #D0D0D0;
    }
    body.light-mode .recent-transactions-table th {
      background-color: #E8E8E8;
      color: #333;
      border-bottom: 1px solid #C0C0C0;
    }
    body.light-mode .recent-transactions-table td {
      color: #555;
      border-bottom: 1px solid #D0D0D0;
    }
    body.light-mode .recent-transactions-table .amount-income {
      color: #00796b;
    }
    body.light-mode .recent-transactions-table .amount-expense {
      color: #d32f2f;
    }
    
    /* Modal Components - Consolidated */
    .upload-modal {
      display: none;
      position: fixed;
      z-index: 1500;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.6);
      align-items: center;
      justify-content: center;
    }
    .upload-modal-content {
      background-color: #1A1625;
      margin: auto;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.7);
      width: 90%;
      max-width: 550px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .upload-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #4F4B68;
    }
    .upload-modal-header h2 {
      color: #E0E0E0;
      font-size: 1.4em;
      margin: 0;
    }
    .upload-modal-close-btn {
      color: #A0A0A0;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
    }
    .upload-modal-close-btn:hover,
    .upload-modal-close-btn:focus {
      color: #FFF;
    }    /* Upload Area Components */
    .upload-area {
      border: 2px dashed #4F4B68;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      background-color: #0D0B14;
      transition: background-color 0.2s, border-color 0.2s;
    }
    .upload-area:hover {
      background-color: #211D30;
      border-color: #63FFDA;
    }
    .upload-area-icon {
      font-size: 40px;
      color: #63FFDA;
      margin-bottom: 15px;
    }
    .upload-area-text {
      color: #E0E0E0;
      font-size: 1.1em;
      margin-bottom: 8px;
    }
    .upload-area-subtext {
      color: #A0A0A0;
      font-size: 0.9em;
    }
    #modalPdfInput {
      display: none;
    }
    #selectedFilesList {
      margin-top: 15px;
      max-height: 100px;
      overflow-y: auto;
      font-size: 0.9em;
      color: #C0C0C0;
    }
    #selectedFilesList div {
      padding: 3px 0;
    }
    .upload-modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding-top: 15px;
      border-top: 1px solid #4F4B68;
    }    /* Universal Button Styling - Consolidated */
    .upload-modal-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.95em;
      transition: background-color 0.2s, color 0.2s;
    }
    .upload-modal-btn.primary {
      background: #63FFDA;
      color: #0D0B14;
    }
    .upload-modal-btn.secondary {
      background: #4F4B68;
      color: #E0E0E0;
    }
    
    /* Progress Bar Component */
    #progressBarContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background-color: #0D0B14;
      padding: 8px 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.7);
      display: none;
      z-index: 9999;
    }
    #progressBar {
      width: 80%;
      margin: 0 auto;
      height: 20px;
      background-color: #63FFDA;
      background-image: linear-gradient(
        45deg,
        rgba(13, 11, 20, 0.25) 25%,
        transparent 25%,
        transparent 50%,
        rgba(13, 11, 20, 0.25) 50%,
        rgba(13, 11, 20, 0.25) 75%,
        transparent 75%,
        transparent
      );
      background-size: 40px 40px;
      border-radius: 5px;
      text-align: center;
      line-height: 20px;
      color: #0D0B14;
      font-weight: bold;
      animation: progressBarAnimation 2s linear infinite;
      transition: width 0.3s ease-in-out;
    }
    @keyframes progressBarAnimation {
      0% { background-position: 40px 0; }
      100% { background-position: 0 0; }
    }    /* Top Controls */
    .top-right-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
    }
    #agent-action-button {
      background-color: #63FFDA;
      color: #0D0B14;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    #agent-action-button:hover {
      background-color: #52D9C3;
    }
    
    /* Consolidated Button States */
    button, .upload-modal-btn, .file-history-tab, .banks-tab, #agent-action-button {
      background: transparent;
      border: 1px solid transparent;
      color: #63FFDA;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      padding: 8px 15px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, box-shadow 0.2s, border-color 0.2s;
      outline: none;
      box-shadow: none;
      text-decoration: none;
      display: inline-block;
      text-align: center;
      vertical-align: middle;
    }
    .file-history-tab, .banks-tab {
      padding: 8px 22px 8px 18px;
    }
    #agent-action-button {
      padding: 10px 15px;
    }
    .upload-modal-btn {
      padding: 10px 20px;
    }
    
    /* Button Hover States */
    button:not(.active):not(:disabled):hover,
    .upload-modal-btn:not(.active):not(:disabled):hover,
    .file-history-tab:not(.active):not(:disabled):hover,
    .banks-tab:not(.active):not(:disabled):hover,
    #agent-action-button:not(.active):not(:disabled):hover {
      background-color: transparent;
      color: #63FFDA;
      border-color: transparent;
      box-shadow: 0 0 8px #63FFDA;
    }
    
    /* Button Active States */
    button.active, button:active,
    .upload-modal-btn.active, .upload-modal-btn:active,
    .file-history-tab.active, .file-history-tab:active,
    .banks-tab.active, .banks-tab:active,
    #agent-action-button.active, #agent-action-button:active {
      background-color: #0D0B14;
      color: #63FFDA;
      border: 1px solid #63FFDA;
      box-shadow: none;
    }
    
    /* Button Disabled States */
    button:disabled,
    .upload-modal-btn:disabled,
    .file-history-tab:disabled,
    .banks-tab:disabled,
    #agent-action-button:disabled {
      color: #4F4B68;
      background-color: #211D30;
      border-color: #4F4B68;
      cursor: not-allowed;
      box-shadow: none;
    }
  </style>

  <!-- Poppins font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <!-- ―――---- added helper libraries ----――― -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script> <!-- Chart.js UMD bundle :contentReference[oaicite:1]{index=1} -->
  <!-- ADDED: Date Adapter for Chart.js Time Scale -->
  <script src="https://cdn.jsdelivr.net/npm/date-fns@3.6.0/cdn.min.js"></script> <!-- date-fns library -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script> <!-- date-fns adapter -->
  <script src="config.js"></script>
  <!-- Ensure config.js is loaded before any other scripts that use GEMINI_API_KEY -->
</head>
<body>
  <div class="sidebar">
    <a href="Landing Page.html" title="Home">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 10L12 3l9 7v11a1 1 0 0 1-1 1h-6v-7h-4v7H4a1 1 0 0 1-1-1V10z"/>
      </svg>
    </a>
    <a href="Personal Finance Tracker.html" title="Finance Tracker">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <polyline points="3 17 8 12 13 16 21 4" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </a>
    <a href="Productivity Tracker.html" title="Productivity Tracker">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="9"/>
        <polyline points="12 7 12 12 15 15" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </a>
  </div>

  <!-- New: Top Right Controls Button -->
  <div class="top-right-controls">
    <button id="agent-action-button">Generate Presentation</button>
  </div>
  <div class="content">
    <h1>Personal Finance Tracker</h1>
    <!-- Modified: This input will now trigger the modal. We'll hide its default appearance. -->
    <input id="pdfPicker" type="file" accept=".pdf" multiple style="display: none;">

    <div id="total"></div>

    <!-- New PDF Upload Modal -->
    <div id="pdfUploadModal" class="upload-modal">
      <div class="upload-modal-content">
        <div class="upload-modal-header">
          <h2>Upload PDF Statements</h2>
          <button id="closeUploadModalBtn" class="upload-modal-close-btn">&times;</button>
        </div>
        
        <label for="modalPdfInput" class="upload-area" id="uploadAreaLabel">
          <div class="upload-area-icon">&#x21E7;</div> <!-- Unicode UPWARDS ARROW -->
          <div class="upload-area-text">Drag & drop files or click to choose files</div>
          <div class="upload-area-subtext">Supported file types: PDF</div>
        </label>
        <input id="modalPdfInput" type="file" accept=".pdf" multiple>
        <div id="selectedFilesList">
          <!-- Selected files will be listed here -->
        </div>

        <div class="upload-modal-footer">
          <button id="cancelUploadBtn" class="upload-modal-btn secondary">Cancel</button>
          <button id="confirmUploadBtn" class="upload-modal-btn primary">Upload</button>
        </div>
      </div>
    </div>
    <!-- End New PDF Upload Modal -->


    <!-- New Net Worth (Monthly Income) Widget -->
    <div class="net-worth-container card">
      <h2>Net Worth</h2>
      <div class="timeframe-controls">
        <button data-chart="netWorth" data-range="day">Day</button>
        <button data-chart="netWorth" data-range="week">Week</button>
        <button data-chart="netWorth" data-range="month" class="active">Month</button>
        <button data-chart="netWorth" data-range="year">Year</button>
      </div>
      <div class="net-worth-chart-inner-container">
        <canvas id="netWorthChartCanvas"></canvas>
      </div>
    </div>

    <!-- Row container for side-by-side charts -->
    <div class="charts-row-container">
      <div class="chart-container card">
        <h2>Expenses</h2> <!-- Changed from Charges vs Payments, removed inline style -->
        <div class="timeframe-controls">
          <button data-chart="expenses" data-range="day">Day</button>
          <button data-chart="expenses" data-range="week">Week</button>
          <button data-chart="expenses" data-range="month" class="active">Month</button>
          <button data-chart="expenses" data-range="year">Year</button>
        </div>
        <div class="charges-payments-chart-inner-container"> <!-- NEW WRAPPER -->
          <canvas id="spendChart"></canvas>
        </div>
      </div>

      <div class="category-chart-container card"> <!-- Ensured .card class is present -->
        <select id="categoryMonthSelector"></select>
        <div class="category-chart-inner-container">
          <canvas id="categorySpendChart"></canvas>
        </div>
      </div>
    </div>

    <!-- New Recent Transactions Widget -->
    <div class="recent-transactions-container card">
      <h2>Recent Transactions</h2>
      <div class="recent-transactions-table-container">
        <table class="recent-transactions-table">
          <thead>
            <!-- Headers will be populated by JS or can be static if known -->
          </thead>
          <tbody id="recentTransactionsBody">
            <!-- Transactions will be populated here by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>    <!-- File History Tab Button -->
    <button id="fileHistoryTab" class="file-history-tab">File History</button>
    <!-- New Banks Tab Button -->
    <button id="banksTab" class="banks-tab">Banks</button>
    <!-- Upload PDF Button, relocated to be right of the Banks button -->
    <button id="openPdfUploadModalBtn" class="banks-tab" style="left: 280px;">Upload PDF</button>

    <div id="fileHistoryPanel" class="file-history-panel">
      <h3>Uploaded Files</h3>
      <ul id="fileHistoryList" class="file-history-list"></ul>
    </div>

    <!-- New Banks Panel (initially hidden) -->
    <div id="banksPanel" class="file-history-panel" style="display:none; position:absolute; top:54px; left:200px; background:#1A1625; color:#E0E0E0; border-radius:0 0 12px 12px; box-shadow:0 4px 16px rgba(0,0,0,0.5); min-width:320px; max-width:420px; padding:18px 18px 10px 18px; z-index:1100;">
      <h3>Banks</h3>
      <ul id="banksList" class="file-history-list">
        <li style="color:#A0A0A0;">No banks added yet.</li>
      </ul>
      <div style="text-align:right; margin-top:12px;">
        <button id="importBanksBtn" class="upload-modal-btn primary">Import</button>
      </div>
    </div>

    <div id="progressBarContainer">
      <div id="progressBar">Processing...</div>
    </div>

    <script>
      // Helper to extract month/year from filename
      function extractMonthYearFromName(name) {
        if (typeof name !== 'string') return null;
        const trimmedName = name.trim();

        const monthMap = {
          jan: 1, january: 1, feb: 2, february: 2, mar: 3, march: 3, apr: 4, april: 4,
          may: 5, jun: 6, june: 6, jul: 7, july: 7, aug: 8, august: 8, sep: 9, september: 9,
          oct: 10, october: 10, nov: 11, november: 11, dec: 12, december: 12
        };
        const monthPattern = '(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sep|Oct|October|November|Nov|December|Dec)';

        const textualMatchMonthYear = trimmedName.match(new RegExp(monthPattern + '\\s+(\\d{4})', 'i'));

        if (textualMatchMonthYear && textualMatchMonthYear[1] && textualMatchMonthYear[2]) {
          const monthName = textualMatchMonthYear[1].toLowerCase();
          const year = parseInt(textualMatchMonthYear[2], 10);
          const month = monthMap[monthName];
          if (month && year >= 1900 && year <= 2100) { // Added year range check
            return { year, month };
          }
        }

        // Fallback: Try to match "YYYY Month" (less common for user's stated format)
        const textualMatchYearMonth = trimmedName.match(new RegExp('(\\d{4})\\s+' + monthPattern, 'i'));
         if (textualMatchYearMonth && textualMatchYearMonth[1] && textualMatchYearMonth[2]) {
          const year = parseInt(textualMatchYearMonth[1], 10);
          const monthName = textualMatchYearMonth[2].toLowerCase();
          const month = monthMap[monthName];
          if (month && year >= 1900 && year <= 2100) {
            return { year, month };
          }
        }

        // Fallback to numeric month and year (e.g., "2025-03", "2025_3")
        const numericDateMatch = trimmedName.match(/(\\d{4})[-_]?([0-1]?[0-9])/);
        if (numericDateMatch && numericDateMatch[1] && numericDateMatch[2]) {
          const year = parseInt(numericDateMatch[1], 10);
          const month = parseInt(numericDateMatch[2], 10);
          if (year >= 1900 && year <= 2100 && month >= 1 && month <= 12) {
            return { year, month };
          }
        }
        console.warn('Could not extract month/year from filename:', name); // Added warning
        return null;
      }
      let chart = null;
      
      let dailyActivity = {}; // New: {"YYYY-MM-DD": {charges: 0, payments: 0, dcIncome: 0, categories: {"Groceries": 0,...}}}
      let globalAllTransactions = []; // New: To store all individual transactions

      let categoryChart = null;
      const CATEGORIES = ["Groceries", "Food Delivery/Restaurant", "Gas", "Misc", "Other"];

      // --- New: N8N Webhook URL ---
      const N8N_WEBHOOK_URL = "https://criticalvuln.app.n8n.cloud/webhook-test/f597b035-7b41-496a-8e8e-f3102a67508a"; // <<< REPLACE WITH YOUR ACTUAL N8N WEBHOOK URL

      // --- New: Net Worth (Income) Chart Global ---
      let netWorthChartInstance = null;
      let sharedChartTimeframe = 'month'; // New: Shared timeframe for Expenses and Net Worth charts

      // API Key will now be loaded from config.js
      const GEMINI_API_KEY = window.APP_CONFIG && window.APP_CONFIG.GEMINI_API_KEY;

      // --- File History State ---
      let fileHistory = JSON.parse(localStorage.getItem('financeFileHistory') || '[]');
  
      let fileDataKeysMap = JSON.parse(localStorage.getItem('financeFileDataKeysMap') || '{}'); // New: {"filename": ["YYYY-MM-DD", ...]}
      let globalAllTransactionsStorageKey = 'financeGlobalAllTransactions'; // New

      const progressBarContainer = document.getElementById('progressBarContainer');
      const progressBar = document.getElementById('progressBar');
      // const originalStatusElement = document.getElementById('yourStatusMessageElementId'); // Optional: Replace ID

      function showProcessingBar(message = "Processing file...") {
   
        if (progressBarContainer && progressBar) {
          progressBar.textContent = message;
          progressBarContainer.style.display = 'block';
        }
      }

      function hideProcessingBar() {
        if (progressBarContainer) {
          progressBarContainer.style.display = 'none';
        }
       
      }
    
      function setupTimeframeControls() {
        const timeframeButtons = document.querySelectorAll('.timeframe-controls button[data-range]');

        timeframeButtons.forEach(button => {
          button.addEventListener('click', (event) => {
            const clickedButton = event.target;
            // Ensure the clicked element is a button with data-range
            if (!clickedButton.matches('button[data-range]')) return;

            const newTimeframe = clickedButton.dataset.range;
            
            // Update the shared timeframe state
            sharedChartTimeframe = newTimeframe;

            // Update 'active' class on ALL timeframe buttons
            document.querySelectorAll('.timeframe-controls button[data-range]').forEach(btn => {
              btn.classList.remove('active');
              if (btn.dataset.range === newTimeframe) {
                btn.classList.add('active');
              }
            });

            // Re-render both charts with the new timeframe
            if (typeof renderSpendChart === 'function') {
              renderSpendChart(sharedChartTimeframe);
            }
            if (typeof renderNetWorthChart === 'function') {
              renderNetWorthChart(sharedChartTimeframe);
            }
          });
        });
      }
      // --- End Synchronized Timeframe Controls Setup ---

      function saveFileDataKeysMap() { // New name
        localStorage.setItem('financeFileDataKeysMap', JSON.stringify(fileDataKeysMap));
      }

      // --- File History UI Logic ---
      const fileHistoryTab = document.getElementById('fileHistoryTab');
      const fileHistoryPanel = document.getElementById('fileHistoryPanel');
      const fileHistoryList = document.getElementById('fileHistoryList');

      function renderFileHistory() {
        // Guard against missing element
        if (!fileHistoryList) return;
        fileHistoryList.innerHTML = '';
        if (!fileHistory.length) {
          fileHistoryList.innerHTML = '<li style="color:#A0A0A0;">No files uploaded yet.</li>';
          return;
        }

        // Sort fileHistory by date (year, then month), then by name for undated files
        fileHistory.sort((a, b) => {
          const dateA = extractMonthYearFromName(a.name);
          const dateB = extractMonthYearFromName(b.name);

          if (dateA && dateB) {
            if (dateA.year !== dateB.year) {
              return dateA.year - dateB.year; // Sort by year ascending
            }
            return dateA.month - dateB.month; // Then by month ascending
          } else if (dateA) {
            return -1; // dateA (has date) comes before dateB (no date)
          } else if (dateB) {
            return 1;  // dateB (has date) comes before dateA (no date)
          } else {
            // Neither has a parseable date, sort by name alphabetically
            return a.name.localeCompare(b.name);
          }
        });

        fileHistory.forEach(f => {
          const li = document.createElement('li');
          const nameSpan = document.createElement('span');
          nameSpan.className = 'filename';
          nameSpan.textContent = f.name;
          const delBtn = document.createElement('button');
          delBtn.className = 'delete-btn';
          delBtn.textContent = 'Delete';
          delBtn.onclick = (event) => { // Add event parameter
            event.stopPropagation(); // Stop the click from bubbling to the document
            deleteFileHistory(f.name);
          };
          li.appendChild(nameSpan);
          li.appendChild(delBtn);
          fileHistoryList.appendChild(li);
        });
      }

      function showFileHistory(show) {
        // Guard against missing elements
        if (!fileHistoryPanel || !fileHistoryTab) return;
         if (show) {
           fileHistoryPanel.style.display = 'block';
           fileHistoryTab.classList.add('active');
           renderFileHistory();
         } else {
           fileHistoryPanel.style.display = 'none';
           fileHistoryTab.classList.remove('active');
         }
      }
      if (fileHistoryTab) {
        fileHistoryTab.addEventListener('click', () => {
          showFileHistory(fileHistoryPanel.style.display !== 'block');
        });
      }
      if (fileHistoryPanel) {
        document.addEventListener('click', e => {
          if (!fileHistoryPanel.contains(e.target) && e.target !== fileHistoryTab) {
            showFileHistory(false);
          }
        });
      }

      function addFileToHistory(name, keys) { // keys are now YYYY-MM-DD
        if (!fileHistory.some(f => f.name === name)) {
          fileHistory.push({ name });
          localStorage.setItem('financeFileHistory', JSON.stringify(fileHistory));
        }
        if (Array.isArray(keys) && keys.length) {
          fileDataKeysMap[name] = keys; // Store daily keys
          saveFileDataKeysMap();
        }
      }
      function deleteFileHistory(name) {
        // Remove from fileHistory
        fileHistory = fileHistory.filter(f => f.name !== name);
        localStorage.setItem('financeFileHistory', JSON.stringify(fileHistory));
        // Remove all data from this file from the charts
        removeFileData(name); // Uses daily keys now
        // Remove mapping
        delete fileDataKeysMap[name];
        saveFileDataKeysMap();
        renderFileHistory();
        // updateDisplay(); // Will be called by updateAndSaveData
        updateAndSaveData();
      }

      // --- New: Helper function to rebuild dailyActivity from globalAllTransactions for specific dates ---
      function rebuildDailyActivityForDates(dateKeysToRebuild) {
        const dates = Array.isArray(dateKeysToRebuild) ? dateKeysToRebuild : Array.from(dateKeysToRebuild);

        dates.forEach(dateKey => {
          // Initialize/clear the specific day's activity
          dailyActivity[dateKey] = { charges: 0, payments: 0, dcIncome: 0, categories: {} };
          CATEGORIES.forEach(cat => dailyActivity[dateKey].categories[cat] = 0); // Ensure all categories are initialized for summing up
        });

        globalAllTransactions.forEach(tx => {
          if (dates.includes(tx.date)) { // Process only if the transaction's date is one we're rebuilding
            const dateKey = tx.date;
            const amount = parseFloat(tx.amount); // Amount is stored as parsed: positive for charge, negative for income/payment
            const isDCFile = tx.sourceFile.toUpperCase().startsWith("DC");

            if (!dailyActivity[dateKey]) { // Should not happen if initialized above, but as a safeguard
              dailyActivity[dateKey] = { charges: 0, payments: 0, dcIncome: 0, categories: {} };
              CATEGORIES.forEach(cat => dailyActivity[dateKey].categories[cat] = 0);
            }

            if (isDCFile) {
              if (amount < 0) { // DC income is stored as negative by parser, dcIncome in dailyActivity is positive
                dailyActivity[dateKey].dcIncome += Math.abs(amount);
              }
            } else { // Not a DC file
              if (amount > 0) { // Charge
                dailyActivity[dateKey].charges += amount;
                let categoryToApply = "Other"; // Default category
                if (tx.category && CATEGORIES.includes(tx.category)) {
                  categoryToApply = tx.category;
                }
                dailyActivity[dateKey].categories[categoryToApply] = (dailyActivity[dateKey].categories[categoryToApply] || 0) + amount;
              } else if (amount < 0) { // Payment
                dailyActivity[dateKey].payments += Math.abs(amount);
              }
            }
          }
        });

        // Clean up days that ended up with no activity after rebuild
        dates.forEach(dateKey => {
          const dayData = dailyActivity[dateKey];
          if (dayData) { // Check if dayData exists, as it might have been deleted by another process if code changes
            let isEmpty = dayData.charges === 0 && dayData.payments === 0 && dayData.dcIncome === 0;
            if (isEmpty) {
              let categoriesSum = 0;
              CATEGORIES.forEach(cat => categoriesSum += (dayData.categories[cat] || 0));
              if (categoriesSum === 0) {
                delete dailyActivity[dateKey];
              }
            }
          }
        });
      }

      function removeFileData(name) {
        const dailyKeysAffectedByThisFile = fileDataKeysMap[name] || [];

        // Remove transactions from globalAllTransactions associated with this file
        globalAllTransactions = globalAllTransactions.filter(tx => tx.sourceFile !== name);
        localStorage.setItem(globalAllTransactionsStorageKey, JSON.stringify(globalAllTransactions));

        // After removing transactions, rebuild dailyActivity for the dates this file affected
        if (dailyKeysAffectedByThisFile.length > 0) {
          rebuildDailyActivityForDates(dailyKeysAffectedByThisFile);
        }
        
        // fileDataKeysMap[name] will be deleted by deleteFileHistory function
        // Totals are recalculated in updateDisplay based on remaining dailyActivity
      }

      // --- On load, render file history ---
      renderFileHistory();
      showFileHistory(false);

      // Update totals display and chart
      function updateDisplay() {
        // Clear numeric summary
        document.getElementById('total').innerHTML = '';

        renderSpendChart(sharedChartTimeframe); // Use shared timeframe

        localStorage.setItem('financeDailyActivity', JSON.stringify(dailyActivity)); // New: Save all daily activity
        localStorage.setItem(globalAllTransactionsStorageKey, JSON.stringify(globalAllTransactions)); // New: Save all transactions

        // Update and render category chart
        populateCategoryMonthSelector();
        const selectedMonthForCategory = document.getElementById('categoryMonthSelector').value;
        renderCategoriesChart(selectedMonthForCategory);

        // Update and render Net Worth (Income) chart
        renderNetWorthChart(sharedChartTimeframe); // Use shared timeframe

        renderRecentTransactions(); // New: Render recent transactions
      }

      // --- New: Update and Save all data ---
      function updateAndSaveData() {
        updateDisplay(); // This now handles saving all primary data to localStorage
        // fileMonthMap is saved by its own function saveFileMonthMap()
      }


      // --- New: Render Recent Transactions ---
      function renderRecentTransactions() {
        const tbody = document.getElementById('recentTransactionsBody');
        tbody.innerHTML = ''; // Clear existing rows

        if (globalAllTransactions.length === 0) {
          const tr = tbody.insertRow();
          const td = tr.insertCell();
          td.colSpan = 5;
          td.textContent = 'No transactions to display yet.';
          td.style.textAlign = 'center';
          td.style.color = '#A0A0A0';
          return;
        }

        // Sort transactions by date, most recent first
        const sortedTransactions = [...globalAllTransactions].sort((a, b) => new Date(b.date) - new Date(a.date));
        
        const recentTransactions = sortedTransactions.slice(0, 10);

        recentTransactions.forEach(tx => {
          const tr = tbody.insertRow();
          
          const dateCell = tr.insertCell();
          dateCell.textContent = tx.date;

          const descCell = tr.insertCell();
          descCell.textContent = tx.description;
          
          const categoryCell = tr.insertCell();
          categoryCell.textContent = tx.category || 'N/A';

          const amountCell = tr.insertCell();
          amountCell.textContent = parseFloat(tx.amount).toFixed(2);
          // Amounts from parser: positive for charges/expenses, negative for income/payments
          if (tx.amount < 0) { // Income or Payment
            amountCell.className = 'amount-income';
            amountCell.textContent = Math.abs(parseFloat(tx.amount)).toFixed(2); // Display as positive
          } else { // Charge or Expense
            amountCell.className = 'amount-expense';
          }
          
          const sourceCell = tr.insertCell();
          sourceCell.textContent = tx.sourceFile;
          sourceCell.style.fontSize = '0.85em';
          sourceCell.style.color = '#888';
        });
      }


      // --- New: Category Chart Functions ---
      function populateCategoryMonthSelector() {
        const selector = document.getElementById('categoryMonthSelector');
        const currentSelection = selector.value; // Expects YYYY-MM
        selector.innerHTML = ''; // Clear existing options

        const availableMonths = new Set();
        Object.keys(dailyActivity).forEach(dateKey_YYYY_MM_DD => {
            availableMonths.add(dateKey_YYYY_MM_DD.substring(0, 7)); // Extract YYYY-MM
        });
        
        const sortedMonths = Array.from(availableMonths).sort().reverse(); // Latest first

        if (sortedMonths.length === 0) {
            const option = document.createElement('option');
            option.value = "";
            option.textContent = "No category data";
            selector.appendChild(option);
            selector.disabled = true;
            return;
        }

        selector.disabled = false;
        sortedMonths.forEach(monthKey_YYYY_MM => { // monthKey is YYYY-MM
            const option = document.createElement('option');
            option.value = monthKey_YYYY_MM;
            const [year, monthNum] = monthKey_YYYY_MM.split('-');
            const monthName = new Date(year, parseInt(monthNum) - 1, 1).toLocaleString('default', { month: 'long' });
            option.textContent = `${monthName} ${year}`;
            selector.appendChild(option);
        });

        if (sortedMonths.includes(currentSelection)) {
            selector.value = currentSelection;
        } else if (sortedMonths.length > 0) {
            selector.value = sortedMonths[0]; // Default to the latest month
        }
      }

      document.getElementById('categoryMonthSelector').addEventListener('change', (event) => {
        renderCategoriesChart(event.target.value); // Value is YYYY-MM
      });

      function renderCategoriesChart(monthKey_YYYY_MM) { // Expects YYYY-MM
        const container = document.querySelector('.category-chart-inner-container');
        container.innerHTML = '<canvas id="categorySpendChart"></canvas>'; // Ensure fresh canvas
        const ctx = document.getElementById('categorySpendChart').getContext('2d');

        if (categoryChart) {
            categoryChart.destroy();
        }

        if (!monthKey_YYYY_MM || !/^\d{4}-\d{2}$/.test(monthKey_YYYY_MM)) { // Validate monthKey format
            ctx.font = "16px Poppins";
            ctx.fillStyle = "#A0A0A0";
            ctx.textAlign = "center";
            ctx.fillText(monthKey_YYYY_MM ? "Invalid period format" : "Select a period", container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }
        
        const aggregatedCategoriesForMonth = {};
        CATEGORIES.forEach(cat => aggregatedCategoriesForMonth[cat] = 0); // Initialize all categories to 0

        let foundDataForMonth = false;
        Object.keys(dailyActivity).forEach(dateKey_YYYY_MM_DD => {
            if (dateKey_YYYY_MM_DD.startsWith(monthKey_YYYY_MM)) { // Check if the date belongs to the selected month
                const dayData = dailyActivity[dateKey_YYYY_MM_DD];
                if (dayData && dayData.categories) {
                    foundDataForMonth = true;
                    CATEGORIES.forEach(cat => {
                        if (dayData.categories[cat]) {
                            aggregatedCategoriesForMonth[cat] += dayData.categories[cat];
                        }
                    });
                }
            }
        });

        if (!foundDataForMonth) {
            ctx.font = "16px Poppins";
            ctx.fillStyle = "#A0A0A0";
            ctx.textAlign = "center";
            ctx.fillText("No category data for selected period", container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }

        const labels = CATEGORIES;
        const rawData = labels.map(cat => aggregatedCategoriesForMonth[cat] || 0);

        const filteredLabels = [];
        const filteredData = [];
        labels.forEach((label, index) => {
            if (rawData[index] > 0) {
                filteredLabels.push(label);
                filteredData.push(rawData[index]);
            }
        });

        if (filteredData.length === 0) {
            ctx.font = "16px Poppins";
            ctx.fillStyle = "#A0A0A0";
            ctx.textAlign = "center";
            ctx.fillText("No spending in categories for " + monthKey_YYYY_MM, container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }
        
        const [year, monthNum] = monthKey_YYYY_MM.split('-');
        const monthName = new Date(year, monthNum - 1, 1).toLocaleString('default', { month: 'long' });
        const chartTitle = `Spending Categories for ${monthName} ${year}`;


        categoryChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: filteredLabels,
                datasets: [{
                    label: 'Spending by Category',
                    data: filteredData,
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.7)', // Groceries
                        'rgba(54, 162, 235, 0.7)', // Food Delivery/Restaurant
                        'rgba(255, 206, 86, 0.7)', // Gas
                        'rgba(75, 192, 192, 0.7)', // Bills
                        'rgba(153, 102, 255, 0.7)', // Other
                        'rgba(255, 159, 64, 0.7)'  // Extra color
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(75, 192, 192, 1)',
                        'rgba(153, 102, 255, 1)',
                        'rgba(255, 159, 64, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { color: '#E0E0E0' }
                    },
                    title: {
                        display: true,
                        text: chartTitle,
                        color: '#E0E0E0',
                        font: { size: 16 }
                    }
                }
            }
        });
      }


      // --- New: Net Worth (Monthly Income) Chart Function ---
      function renderNetWorthChart(timeframe = 'month') {
        const canvas = document.getElementById('netWorthChartCanvas');
        if (!canvas) return; // Ensure canvas exists
        const ctx = canvas.getContext('2d');
        
        if (netWorthChartInstance) {
            netWorthChartInstance.destroy();
        }

        const { labels: incomeDays, data: incomeData } = aggregateDataForChart(dailyActivity, timeframe, 'dcIncome');

        const container = document.querySelector('.net-worth-chart-inner-container');
        if (incomeDays.length === 0) {
            // Clear previous chart content and display a message
            container.innerHTML = '<canvas id="netWorthChartCanvas"></canvas>'; // Re-add canvas
            const newCtx = document.getElementById('netWorthChartCanvas').getContext('2d');
            newCtx.font = "16px Poppins";
            newCtx.fillStyle = "#A0A0A0";
            newCtx.textAlign = "center";
            newCtx.fillText("Net Worth data from 'DC' files will appear here.", container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }
        
        // Create gradient for the line chart fill
        const gradientGreen = ctx.createLinearGradient(0, 0, 0, container.offsetHeight); // Adjust gradient height if needed
        gradientGreen.addColorStop(0, 'rgba(76, 255, 76, 0.4)'); // Green with 40% opacity
        gradientGreen.addColorStop(1, 'rgba(76, 255, 76, 0)');   // Green with 0% opacity

        netWorthChartInstance = new Chart(ctx, {
          type: 'line', 
          data: {
            labels: incomeDays.map(dateKey => { // Format YYYY-MM-DD to Month Day
                const [year, monthNum, dayNum] = dateKey.split('-');
                // return new Date(year, parseInt(monthNum) - 1, parseInt(dayNum)).toLocaleDateString('default', { month: 'short', day: 'numeric' });
                return `${monthNum.padStart(2, '0')}/${dayNum.padStart(2, '0')}`; // MM/DD format
            }),
            datasets: [
              {
                label: 'Net Worth (Income from DC files)', // Updated label
                data: incomeData,
                backgroundColor: gradientGreen, // Apply gradient fill
                borderColor: '#4CFF4C', // Green line
                borderWidth: 2, // Line thickness
                fill: true, // Enable fill
                tension: 0.4, // Smooth curve
                pointRadius: 4, // Size of the points
                pointBackgroundColor: '#4CFF4C', // Green points
                pointBorderColor: '#1A1625', // Match card background for point border
                pointHoverRadius: 7, // Size of points on hover
                pointHoverBackgroundColor: '#4CFF4C',
                pointHoverBorderColor: '#FFF' 
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { 
                grid: { color: '#333' }, 
                ticks: { 
                    color: '#ccc',
                    // autoSkip: true, // May be useful for many data points
                    // maxTicksLimit: 20 // Adjust as needed
                } 
              },
              y: { grid: { color: '#333' }, ticks: { color: '#ccc' }, beginAtZero: true }
            },
            plugins: {
              legend: { display: true, labels: { color: '#E0E0E0' } },
              title: {
                display: false, // Main title is in H2
                // text: 'Monthly Income Over Time', // Already have H2
                color: '#E0E0E0'
              }
            }
          }
        });
      }

      // --- New: Aggregate data for charts based on timeframe ---
      function aggregateDataForChart(sourceData, timeframe, dataType) {
        const now = new Date();
        let labels = [];
        let data = [];
        const aggregated = {}; // Temp object to sum data for periods

        const allSortedDates = Object.keys(sourceData).sort();

        allSortedDates.forEach(dateKey => {
          const entry = sourceData[dateKey];
          const value = entry ? (entry[dataType] || 0) : 0;
          if (value === 0 && dataType === 'dcIncome') return; // For net worth, skip if no income

          const date = new Date(dateKey + 'T00:00:00'); // Ensure local timezone interpretation

          let periodKey = '';

          if (timeframe === 'day') {
            periodKey = dateKey; // YYYY-MM-DD
          } else if (timeframe === 'week') {
            const weekStart = new Date(date);
            weekStart.setDate(date.getDate() - date.getDay()); // Sunday
            periodKey = `${weekStart.getFullYear()}-${(weekStart.getMonth() + 1).toString().padStart(2, '0')}-${weekStart.getDate().toString().padStart(2, '0')}`;
          } else if (timeframe === 'month') {
            periodKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
          } else if (timeframe === 'year') {
            periodKey = date.getFullYear().toString();
          }

          if (periodKey) {
            aggregated[periodKey] = (aggregated[periodKey] || 0) + value;
          }
        });

        labels = Object.keys(aggregated).sort();
        data = labels.map(key => aggregated[key]);
        
        // Format labels for display
        const formattedLabels = labels.map(label => {
            if (timeframe === 'day') {
                const [y, m, d] = label.split('-');
                return `${m}/${d}`;
            }
            if (timeframe === 'week') {
                 const [y, m, d] = label.split('-');
                return `Wk ${m}/${d}`;
            }
            if (timeframe === 'month') {
                const [y,m] = label.split('-');
                return new Date(y, parseInt(m)-1, 1).toLocaleString('default', { month: 'short' });
            }
            if (timeframe === 'year') {
                return label;
            }
            return label;
        });

        return { labels: formattedLabels, data };
      }

      // --- Modified: renderSpendChart to accept timeframe ---
      function renderSpendChart(timeframe = 'month') {
        const { labels: chartLabels, data: chargesData } = aggregateDataForChart(dailyActivity, timeframe, 'charges');
        const { data: paymentsData } = aggregateDataForChart(dailyActivity, timeframe, 'payments'); // Labels will be the same

        if (chart) chart.destroy();
        chart = new Chart(document.getElementById('spendChart'), {
          type: 'bar',
          data: {
            labels: chartLabels,
            datasets: [
              {
                label: 'Charges',
                data: chargesData,
                backgroundColor: '#FF4C4C',
                borderColor: '#1A1625',
                borderWidth: 1
              },
              {
                label: 'Payments',
                data: paymentsData,
                backgroundColor: '#4CFF4C',
                borderColor: '#1A1625',
                borderWidth: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                grid: { color: '#333' },
                ticks: { color: '#ccc' }
              },
              y: { grid: { color: '#333' }, ticks: { color: '#ccc' }, beginAtZero: true }
            },
            plugins: {
              legend: { labels: { color: '#E0E0E0' } },
              title: { display: false, text: 'Expenses Over Time', color: '#E0E0E0' }
            }
          }
        });
      }

      // --- Event Listeners for Timeframe Controls ---
      document.querySelectorAll('.timeframe-controls button').forEach(button => {
        button.addEventListener('click', () => {
          const chartName = button.dataset.chart;
          const range = button.dataset.range;

          // Remove active class from all buttons in this group
          button.parentElement.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
          // Add active class to the clicked button
          button.classList.add('active');

          if (chartName === 'expenses') {
            expensesChartTimeframe = range;
            renderSpendChart(expensesChartTimeframe);
          } else if (chartName === 'netWorth') {
            netWorthChartTimeframe = range;
            renderNetWorthChart(netWorthChartTimeframe);
          }
        });
      });

      // On load, restore saved data
      document.addEventListener('DOMContentLoaded', () => {
        const savedDailyActivity = localStorage.getItem('financeDailyActivity');
        if (savedDailyActivity) {
          dailyActivity = JSON.parse(savedDailyActivity);
        } else {
          dailyActivity = {}; // Initialize if nothing is saved
        }

        const savedGlobalTransactions = localStorage.getItem(globalAllTransactionsStorageKey);
        if (savedGlobalTransactions) {
          globalAllTransactions = JSON.parse(savedGlobalTransactions);
        } else {
          globalAllTransactions = [];
        }

        // fileHistory is already loaded at the top
        const savedFileDataKeysMap = localStorage.getItem('financeFileDataKeysMap');
        if (savedFileDataKeysMap) {
          fileDataKeysMap = JSON.parse(savedFileDataKeysMap);
        } else {
          fileDataKeysMap = {}; // Initialize if nothing is saved
        }

        updateDisplay(); // Call once after all data is loaded
      });

      // --- New: PDF Upload Modal Logic ---
      const pdfUploadModal = document.getElementById('pdfUploadModal');
      const openPdfUploadModalBtn = document.getElementById('openPdfUploadModalBtn');
      const closeUploadModalBtn = document.getElementById('closeUploadModalBtn');
      const modalPdfInput = document.getElementById('modalPdfInput');
      const uploadAreaLabel = document.getElementById('uploadAreaLabel');
      const selectedFilesList = document.getElementById('selectedFilesList');
      const confirmUploadBtn = document.getElementById('confirmUploadBtn');
      const cancelUploadBtn = document.getElementById('cancelUploadBtn');
      const originalPdfPicker = document.getElementById('pdfPicker'); // The original, now hidden, input

      let filesToUploadModal = []; // Renamed to avoid conflict

      if (openPdfUploadModalBtn) {
        openPdfUploadModalBtn.onclick = () => {
          pdfUploadModal.style.display = 'flex';
          filesToUploadModal = []; // Reset on open
          updateSelectedFilesListModal(); // Renamed to avoid conflict
        };
      }

      if (closeUploadModalBtn) {
        closeUploadModalBtn.onclick = () => {
          pdfUploadModal.style.display = 'none';
        };
      }

      if (cancelUploadBtn) {
        cancelUploadBtn.onclick = () => {
          pdfUploadModal.style.display = 'none';
        };
      }

      if (modalPdfInput) {
        modalPdfInput.onchange = (e) => {
          const newFiles = Array.from(e.target.files);
          newFiles.forEach(file => {
            if (file.type === "application/pdf" && !filesToUploadModal.some(existingFile => existingFile.name === file.name && existingFile.size === file.size)) {
              filesToUploadModal.push(file);
            }
          });
          updateSelectedFilesListModal(); 
          modalPdfInput.value = ''; // Clear input to allow re-selecting/re-adding the same file if needed
        };
      }

      function updateSelectedFilesListModal() { // Renamed to avoid conflict
        if (!selectedFilesList) return;
        selectedFilesList.innerHTML = '';
        if (filesToUploadModal.length === 0) {
          selectedFilesList.innerHTML = '<div>No files selected.</div>';
        } else {
          filesToUploadModal.forEach(file => {
            const fileDiv = document.createElement('div');
            fileDiv.textContent = file.name;
            selectedFilesList.appendChild(fileDiv);
          });
        }
        if (confirmUploadBtn) confirmUploadBtn.disabled = filesToUploadModal.length === 0;
      }

      if (confirmUploadBtn) {
        confirmUploadBtn.onclick = async () => {
          if (filesToUploadModal.length > 0) {
            showProcessingBar("Preparing to upload..."); // Show progress bar
            pdfUploadModal.style.display = 'none';
            const dataTransfer = new DataTransfer();
            filesToUploadModal.forEach(file => dataTransfer.items.add(file));
            if (originalPdfPicker) originalPdfPicker.files = dataTransfer.files;
            
            const event = new Event('change', { bubbles: true });
            if (originalPdfPicker) originalPdfPicker.dispatchEvent(event);
          }
        };
      }

      // Close modal if user clicks outside of it
      window.onclick = (event) => {
        if (event.target == pdfUploadModal) {
          pdfUploadModal.style.display = 'none';
        }
      };

      // Drag and drop functionality for the upload area
      if (uploadAreaLabel) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          uploadAreaLabel.addEventListener(eventName, preventDefaultsModal, false); // Renamed to avoid conflict
        });

        function preventDefaultsModal(e) { // Renamed to avoid conflict
          e.preventDefault();
          e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
          uploadAreaLabel.addEventListener(eventName, () => uploadAreaLabel.classList.add('hover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
          uploadAreaLabel.addEventListener(eventName, () => uploadAreaLabel.classList.remove('hover'), false);
        });

        uploadAreaLabel.addEventListener('drop', (e) => {
          const dt = e.dataTransfer;
          const droppedFiles = Array.from(dt.files).filter(file => file.type === "application/pdf");
          
          if (droppedFiles.length > 0) {
              droppedFiles.forEach(file => {
                if (!filesToUploadModal.some(existingFile => existingFile.name === file.name && existingFile.size === file.size)) {
                  filesToUploadModal.push(file);
                }
              });
              updateSelectedFilesListModal(); 
          } else if (dt.files.length > 0) {
              alert("Please drop PDF files only.");
          }
          if (modalPdfInput) modalPdfInput.value = ''; 
        }, false);
      }

      if (originalPdfPicker) {
        originalPdfPicker.addEventListener('change', async e => { 
          const files = Array.from(e.target.files); // These are the files confirmed from the modal
          if (!files.length) {
            hideProcessingBar(); // Hide if no files somehow
            return;
          }

         

          if (!GEMINI_API_KEY || GEMINI_API_KEY.trim() === "") {
            alert("Gemini API key is not set or is invalid. Please create config.js with your key (set GEMINI_API_KEY) and ensure it is loaded.");
            e.target.value = null;
            hideProcessingBar();
            return;
          }

          // if (h1Title) h1Title.textContent = `Processing ${files.length} file(s)...`; // Replaced by progress bar
          showProcessingBar(`Processing ${files.length} file(s)...`); // Show progress bar

          try {
            for (let i = 0; i < files.length; i++) {
              const f = files[i];
              const fileName = f.name;
              const fileExtension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();

              // if (h1Title) h1Title.textContent = `Processing ${fileName} (${i + 1} of ${files.length})...`; // Replaced by progress bar
              showProcessingBar(`Processing ${fileName} (${i + 1} of ${files.length})...`); // Update progress bar message

              if (fileExtension === 'pdf') {
                try {
                  await handlePdfFile(f); 
                } catch (error) {
                  console.error(`Error processing ${fileName}:`, error);
                  alert(`An error occurred while processing ${fileName}. Check the console for details.`);
                  // Optionally, break or decide how to handle errors for multiple files
                }
              } else {
                alert("Unsupported file type. Please upload a PDF file.");
                e.target.value = null; 
                // if (h1Title) h1Title.textContent = originalPageTitle; // No longer needed
                break; 
              }
            }
          } finally {
            updateAndSaveData(); // <<< KEY FIX: Update display and save data after all files are processed
            // if (h1Title) h1Title.textContent = originalPageTitle; // No longer needed
            hideProcessingBar(); // Hide progress bar when all processing is done or an error broke the loop
            e.target.value = null; // Clear the file input to allow re-uploading the same file(s)
          }
        });
      }

      // --- Function to process PDF files (placeholder for OpenAI API call) ---
      async function handlePdfFile(file) {
        const fileName = file.name;
        console.log(`Attempting to process PDF: ${fileName}`);

        // Store old keys this file affected, to ensure they are rebuilt correctly
        const oldKeysForThisFile = fileDataKeysMap[fileName] ? new Set(fileDataKeysMap[fileName]) : new Set();
        
        // First, remove any existing transactions from this file to prevent duplication if re-uploaded
        globalAllTransactions = globalAllTransactions.filter(tx => tx.sourceFile !== fileName);
        // Note: At this point, dailyActivity might be stale for oldKeysForThisFile until rebuild happens.

        try {

          const base64File = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result); 
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file); 
          });

          const pureBase64 = base64File.substring(base64File.indexOf(',') + 1);
          
          const extractedData = await callGeminiPdfParser(pureBase64, fileName);

          let newContributedDailyKeys = new Set();

          if (!extractedData || !extractedData.transactions || !Array.isArray(extractedData.transactions)) {
            console.error('No transactions found or invalid format from parser for file:', fileName);
            addFileToHistory(fileName, []); // Update history with no keys for this file
            // Rebuild any dates this file previously affected to clear its old contributions
            if (oldKeysForThisFile.size > 0) {
                rebuildDailyActivityForDates(Array.from(oldKeysForThisFile));
            }
            return; 
          }

          const isDCFile = fileName.toUpperCase().startsWith("DC"); // Determine once

          if (extractedData.transactions.length === 0) {
            console.log(`No transactions extracted from ${fileName}.`);
            addFileToHistory(fileName, []); 
          } else {
            extractedData.transactions.forEach(transaction => {
              const transactionDate = transaction.date; 
              
              if (!transactionDate || !/^\d{4}-\d{2}-\d{2}$/.test(transactionDate)) {
                console.warn(`Skipping transaction in ${fileName} due to missing or invalid date:`, transaction);
                return; 
              }
              
              const amount = parseFloat(transaction.amount);
              if (isNaN(amount)) {
                console.warn(`Skipping transaction in ${fileName} due to invalid amount:`, transaction);
                return; 
              }
              newContributedDailyKeys.add(transactionDate);

              globalAllTransactions.push({
                date: transactionDate,
                description: transaction.description,
                amount: amount, 
                category: transaction.category || (isDCFile ? 'Income' : 'N/A'),
                sourceFile: fileName
              });
            });
            addFileToHistory(fileName, Array.from(newContributedDailyKeys));
          }

          // Combine old and new keys to ensure all affected dates are rebuilt
          const allAffectedKeys = new Set([...oldKeysForThisFile, ...newContributedDailyKeys]);
          if (allAffectedKeys.size > 0) {
            rebuildDailyActivityForDates(Array.from(allAffectedKeys));
          }

        } catch (error) {
          console.error(`Error in handlePdfFile for ${fileName}:`, error);

          if (oldKeysForThisFile.size > 0) {
             rebuildDailyActivityForDates(Array.from(oldKeysForThisFile));
          }
          throw error; 
        }
      }

      async function callGeminiPdfParser(base64Pdf, fileNameForContext) {
        console.log(`Sending ${fileNameForContext} to Google Gemini API for parsing...`);
        if (!GEMINI_API_KEY) {
            throw new Error("Gemini API key is not loaded. Please check config.js.");
        }
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;


        let systemInstructionText = `You are a data extraction AI. You will receive a PDF bank statement. Your task is to:
1. Identify all individual financial transaction lines. Focus on itemized entries, not summary totals unless they are the only source for a specific transaction type.
2. For each transaction found, extract the date, description, and amount.
3. For each transaction identified as an expense (typically a positive amount based on the rules below), categorize it into one of the following: 'Groceries', 'Food Delivery/Restaurant', 'Gas', 'Misc', 'Other'. If a transaction is a credit/payment (negative amount), the category field can be null or an empty string.

Return a single JSON object: \`{ "transactions": [ { "date": "YYYY-MM-DD", "description": "...", "amount": number, "category": "string_or_null" }, ... ] }\`.

CRITICAL RULES for 'amount':
  - Charges/Debits/Purchases/Expenses/Withdrawals are POSITIVE numbers (e.g., 100.00).
  - Payments/Credits/Deposits/Income are NEGATIVE numbers (e.g., -50.00).
  - Examine transaction descriptions for keywords like 'Purchase', 'Fee', 'Withdrawal' (positive) or 'Payment', 'Deposit', 'Credit', 'Income' (negative).
  - If the PDF text clearly shows 'Debit' and 'Credit' columns, amounts in a 'Debit' column are positive, and amounts in a 'Credit' column are negative.

For 'date': Use 'YYYY-MM-DD'. If the full date isn't on the transaction line, infer the year and month from the overall statement period (often found in the filename or at the top/bottom of the PDF text). If day is missing, use '01'.
For 'description': Capture the full transaction detail as presented on the statement.

Category definitions for expenses:
- 'Groceries': Purchases from supermarkets, grocery stores (e.g., Walmart, Kroger, Trader Joe's, ALDI, Whole Foods).
- 'Food Delivery/Restaurant': Expenses at restaurants, cafes, fast food establishments, and food delivery services (e.g., Doordash, Uber Eats, Grubhub, Starbucks, McDonald's, local restaurants).
- 'Gas': Fuel purchases from gas stations (e.g., Shell, Exxon, BP, Chevron, local gas stations).
- 'Misc': This category is for all other expenses that do not clearly fall into 'Groceries', 'Food Delivery/Restaurant', or 'Gas'. This includes but is not limited to: utility payments (electricity, water, internet, phone), subscriptions (Netflix, Spotify, gym), shopping (clothing, electronics, household goods), entertainment (movies, concerts), travel costs (flights, hotels, not gas), medical co-pays, insurance premiums, rent/mortgage payments, loan repayments, childcare fees, property taxes. If an expense doesn't fit the specific categories above, it should be classified as 'Misc'.
- 'Other': Use this category sparingly for expenses that are highly unusual or cannot be classified even under the broad 'Misc' category. For most unclassified expenses, 'Misc' is preferred. This could also be used if an item is clearly an expense but its nature is completely indeterminable.

The response MUST be only the valid JSON object, with no extra text, explanations, or markdown formatting.`;

        // Check if the filename starts with "DC"
        if (fileNameForContext && fileNameForContext.toUpperCase().startsWith("DC")) {
          // Modify system instruction for "DC" files to only extract income (payments/credits)
          // and not categorize expenses.
          systemInstructionText = `You are a data extraction AI. You will receive a PDF bank statement from a file named '${fileNameForContext}'.
This file is specifically for income. Your task is to:
1. Identify all individual financial transaction lines that represent INCOME or CREDITS to the account.
2. For each such transaction found, extract the date, description, and amount.
3. IGNORE ALL EXPENSES/CHARGES/DEBITS. Only process income/credits.

Return a single JSON object: \`{ "transactions": [ { "date": "YYYY-MM-DD", "description": "...", "amount": number, "category": null }, ... ] }\`.

CRITICAL RULES for 'amount':
  - Payments/Credits/Deposits/Income are NEGATIVE numbers (e.g., -50.00).
  - ALL OTHER TRANSACTION TYPES (CHARGES/DEBITS/EXPENSES) SHOULD BE IGNORED.

For 'date': Use 'YYYY-MM-DD'. If the full date isn't on the transaction line, infer the year and month from the overall statement period. If day is missing, use '01'.
For 'description': Capture the full transaction detail.
The 'category' field should always be null for these income transactions.

The response MUST be only the valid JSON object, with no extra text, explanations, or markdown formatting.`;
        }


        const userPromptText = `Please analyze the attached PDF bank statement named '${fileNameForContext}' and extract all financial transactions according to the detailed system instructions. Pay utmost attention to correctly identifying and signing the 'amount' for each transaction (positive for charges, negative for payments/credits) and categorizing expenses.`;

        const payload = {
          contents: [
            {
              parts: [
                { text: userPromptText },
                {
                  inline_data: {
                    mime_type: "application/pdf",
                    data: base64Pdf
                  }
                }
              ]
            }
          ],
          system_instruction: {
            parts: [
              { text: systemInstructionText }
            ]
          },
          generationConfig: {
            response_mime_type: "application/json",
            temperature: 0.2 
          }
        };

        try {
          const response = await fetch(API_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorBody = await response.json().catch(() => response.text()); // Try to parse as JSON, fallback to text
            console.error("Gemini API Error Response:", errorBody);
            const errorMessage = errorBody.error && errorBody.error.message ? errorBody.error.message : JSON.stringify(errorBody);
            throw new Error(`Gemini API request failed with status ${response.status}: ${response.statusText}. Details: ${errorMessage}`);
          }

          const data = await response.json();
          console.log("Gemini API Raw Response:", data);

          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text) {
            const jsonString = data.candidates[0].content.parts[0].text;
            console.log("Gemini API JSON String Content:", jsonString);
            try {
                return JSON.parse(jsonString);
            } catch (parseError) {
                console.error("Failed to parse JSON from Gemini response:", parseError, "Raw content:", jsonString);
                // Check if it might already be an object (though API docs say it's a string with response_mime_type: "application/json")
                if (typeof jsonString === 'object') return jsonString;
                throw new Error("Failed to parse JSON from Gemini API response. Check console for raw output.");
            }
          } else {
            console.error("Unexpected Gemini API response structure:", data);
            throw new Error("Unexpected response structure from Gemini API. No valid content found.");
          }
        } catch (error) {
          console.error("Error calling Gemini API:", error);
          // Display a more user-friendly error message on the page
          const errorDisplay = document.getElementById('apiErrorDisplay'); // Assuming you add such an element
          if (errorDisplay) {
            errorDisplay.textContent = `Error communicating with the AI: ${error.message}. Please check your API key and network connection.`;
          }
          return { transactions: [], summary: "Error during parsing." }; // Return empty on error
        }
      }

      // --- Banks Panel UI Logic ---
      const banksTab = document.getElementById('banksTab');
      let banksPanel = document.getElementById('banksPanel');
      const banksList = document.getElementById('banksList');

      // Helper: Get/Set banks links in localStorage
      function getBankLinks() {
        try {
          return JSON.parse(localStorage.getItem('financeBanksLinks')) || [];
        } catch (e) {
          return [];
        }
      }
      function setBankLinks(links) {
        localStorage.setItem('financeBanksLinks', JSON.stringify(links));
      }

      // Render the banks list in the popup
      function renderBanksList() {
        if (!banksList) return;
        const links = getBankLinks();
        banksList.innerHTML = '';
        if (!links.length) {
          const li = document.createElement('li');
          li.style.color = '#A0A0A0';
          li.textContent = 'No banks added yet.';
          banksList.appendChild(li);
          return;
        }
        links.forEach(link => {
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.href = link.url;
          a.textContent = link.name;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.style.color = '#7adfff';
          a.style.textDecoration = 'underline';
          li.appendChild(a);
          // --- Add delete button next to each bank ---
          const delBtn = document.createElement('button');
          delBtn.className = 'delete-btn';
          delBtn.textContent = 'Delete';
          delBtn.onclick = (event) => {
            event.stopPropagation();
            // Remove this bank from storage and re-render
            const links = getBankLinks();
            const idx = links.findIndex(l => l.name === link.name && l.url === link.url);
            if (idx !== -1) {
              links.splice(idx, 1);
              setBankLinks(links);
              renderBanksList();
            }
          };
          li.appendChild(delBtn);
          banksList.appendChild(li);
        });
      }

      // Initial render on page load
      renderBanksList();

      function showBanksPanel(show) {
        if (!banksPanel || !banksTab) return;
        if (show) {
          banksPanel.style.display = 'block';
          banksTab.classList.add('active');
          renderBanksList(); // Always update when shown
        } else {
          banksPanel.style.display = 'none';
          banksTab.classList.remove('active');
        }
      }
      if (banksTab) {
        banksTab.addEventListener('click', () => {
          showBanksPanel(banksPanel.style.display !== 'block');
        });
      }
      if (banksPanel) {
        document.addEventListener('click', e => {
          if (!banksPanel.contains(e.target) && e.target !== banksTab) {
            showBanksPanel(false);
          }
        });
      }

      // --- Banks Import Modal Logic ---
      // Create the modal HTML and append to body (hidden by default)
      (function createBanksImportModal() {
        if (document.getElementById('banksImportModal')) return; // Prevent duplicate
        const modal = document.createElement('div');
        modal.id = 'banksImportModal';
        modal.className = 'upload-modal';
        modal.style.display = 'none';
        modal.innerHTML = `
          <div class="upload-modal-content">
            <div class="upload-modal-header">
              <h2>Add Bank Link</h2>
              <button id="closeBanksImportModalBtn" class="upload-modal-close-btn">&times;</button>
            </div>
            <div style="display:flex; flex-direction:column; gap:16px;">
              <input id="bankNameInput" type="text" placeholder="Bank Name" style="padding:10px; border-radius:4px; border:1px solid #4F4B68; background:#211D30; color:#E0E0E0; font-size:1em;" />
              <input id="bankUrlInput" type="text" placeholder="Bank URL (https://...)" style="padding:10px; border-radius:4px; border:1px solid #4F4B68; background:#211D30; color:#E0E0E0; font-size:1em;" />
            </div>
            <div class="upload-modal-footer">
              <button id="cancelBanksImportBtn" class="upload-modal-btn secondary">Cancel</button>
              <button id="saveBanksImportBtn" class="upload-modal-btn primary">Save</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      })();

      // Show/hide logic for the modal
      const banksImportModal = document.getElementById('banksImportModal');
      const importBanksBtn = document.getElementById('importBanksBtn');
      if (importBanksBtn && banksImportModal) {
        banksImportModal.style.display = 'none'; // Ensure it's hidden by default
        importBanksBtn.onclick = () => {
          banksImportModal.style.display = 'flex';
          document.getElementById('bankNameInput').value = '';
          document.getElementById('bankUrlInput').value = '';
        };
      }
      const closeBanksImportModalBtn = document.getElementById('closeBanksImportModalBtn');
      const cancelBanksImportBtn = document.getElementById('cancelBanksImportBtn');
      if (closeBanksImportModalBtn) closeBanksImportModalBtn.onclick = () => { banksImportModal.style.display = 'none'; };
      if (cancelBanksImportBtn) cancelBanksImportBtn.onclick = () => { banksImportModal.style.display = 'none'; };
      // Close modal if user clicks outside of it
      window.addEventListener('click', function(event) {
        if (event.target === banksImportModal) {
          banksImportModal.style.display = 'none';
        }
      });

      // --- Banks Import Modal Save Logic ---
      const saveBanksImportBtn = document.getElementById('saveBanksImportBtn');
      if (saveBanksImportBtn) {
        saveBanksImportBtn.onclick = () => {
          const name = document.getElementById('bankNameInput').value.trim();
          const url = document.getElementById('bankUrlInput').value.trim();
          if (!name || !url) {
            alert('Please enter both a bank name and URL.');
            return;
          }
          // Basic URL validation
          if (!/^https?:\/\//i.test(url)) {
            alert('Please enter a valid URL starting with http:// or https://');
            return;
          }
          const links = getBankLinks();
          links.push({ name, url });
          setBankLinks(links);
          renderBanksList();
          banksImportModal.style.display = 'none';
        };
      }

      // --- New: Presentation Generation Logic ---
      async function generatePresentationData() {
        const presentationData = {};
        const today = new Date();
        const formattedToday = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;

        // Slide 1: Title Slide
        presentationData.slide1 = {
          title: "Personal Finance Overview",
          subtitle: `Generated on: ${formattedToday}`
        };

        // Helper to get overall financial summary
        function getOverallSummary() {
          let totalIncome = 0;
          let totalExpenses = 0;
          let firstDate = null;
          let lastDate = null;

          const dates = Object.keys(dailyActivity).sort();
          if (dates.length > 0) {
            firstDate = dates[0];
            lastDate = dates[dates.length - 1];
          }

          Object.values(dailyActivity).forEach(day => {
            totalIncome += day.dcIncome || 0;
            totalExpenses += day.charges || 0;
          });

          return {
            totalIncome: totalIncome.toFixed(2),
            totalExpenses: totalExpenses.toFixed(2),
            net: (totalIncome - totalExpenses).toFixed(2),
            periodCovered: firstDate && lastDate ? `Data from ${firstDate} to ${lastDate}` : "No data available"
          };
        }
        presentationData.slide2 = getOverallSummary();

        // Helper to get monthly aggregates
        function getMonthlyAggregates(dataType) { // dataType can be 'dcIncome' or 'charges'
          const monthly = {};
          Object.entries(dailyActivity).forEach(([dateKey, data]) => {
            const monthKey = dateKey.substring(0, 7); // YYYY-MM
            monthly[monthKey] = (monthly[monthKey] || 0) + (data[dataType] || 0);
          });
          return monthly;
        }

        // Slide 3: Income Highlights
        const monthlyIncome = getMonthlyAggregates('dcIncome');
        let totalIncomeThisMonth = 0;
        let highestIncomeMonthAmount = 0;
        let highestIncomeMonth = "N/A";
        const currentMonthKey = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}`;

        if (monthlyIncome[currentMonthKey]) {
          totalIncomeThisMonth = monthlyIncome[currentMonthKey];
        }
        for (const [month, amount] of Object.entries(monthlyIncome)) {
          if (amount > highestIncomeMonthAmount) {
            highestIncomeMonthAmount = amount;
            highestIncomeMonth = month;
          }
        }
        presentationData.slide3 = {
          title: "Income Highlights",
          totalIncomeThisMonth: totalIncomeThisMonth.toFixed(2),
          highestIncomeMonth: `${highestIncomeMonth} (${highestIncomeMonthAmount.toFixed(2)})`,
          // You could add more insights here, e.g., average monthly income
        };

        // Slide 4: Expense Highlights
        const monthlyExpenses = getMonthlyAggregates('charges');
        let totalExpensesThisMonth = 0;
        let highestExpenseMonthAmount = 0;
        let highestExpenseMonth = "N/A";

        if (monthlyExpenses[currentMonthKey]) {
          totalExpensesThisMonth = monthlyExpenses[currentMonthKey];
        }
        for (const [month, amount] of Object.entries(monthlyExpenses)) {
          if (amount > highestExpenseMonthAmount) {
            highestExpenseMonthAmount = amount;
            highestExpenseMonth = month;
          }
        }
        presentationData.slide4 = {
          title: "Expense Highlights",
          totalExpensesThisMonth: totalExpensesThisMonth.toFixed(2),
          highestExpenseMonth: `${highestExpenseMonth} (${highestExpenseMonthAmount.toFixed(2)})`,
          // You could add more insights here, e.g., average monthly expenses
        };
        
        // Slide 5: Top Expense Categories (for the most recent month with data)
        function getTopExpenseCategories() {
            const availableMonths = new Set();
            Object.keys(dailyActivity).forEach(dateKey_YYYY_MM_DD => {
                if (dailyActivity[dateKey_YYYY_MM_DD] && Object.keys(dailyActivity[dateKey_YYYY_MM_DD].categories).length > 0) {
                    availableMonths.add(dateKey_YYYY_MM_DD.substring(0, 7)); // YYYY-MM
                }
            });
            const sortedMonths = Array.from(availableMonths).sort().reverse();
            let topCategories = "No category data available for recent months.";

            if (sortedMonths.length > 0) {
                const latestMonthKey = sortedMonths[0];
                const aggregatedCategories = {};
                CATEGORIES.forEach(cat => aggregatedCategories[cat] = 0);

                Object.keys(dailyActivity).forEach(dateKey_YYYY_MM_DD => {
                    if (dateKey_YYYY_MM_DD.startsWith(latestMonthKey)) {
                        const dayData = dailyActivity[dateKey_YYYY_MM_DD];
                        if (dayData && dayData.categories) {
                            CATEGORIES.forEach(cat => {
                                if (dayData.categories[cat]) {
                                    aggregatedCategories[cat] += dayData.categories[cat];
                                }
                            });
                        }
                    }
                });
                
                const sortedTopCategories = Object.entries(aggregatedCategories)
                    .filter(([_, amount]) => amount > 0)
                    .sort(([, a], [, b]) => b - a)
                    .slice(0, 5); // Top 5 categories

                if (sortedTopCategories.length > 0) {
                    topCategories = sortedTopCategories.map(([name, amount]) => `${name}: ${amount.toFixed(2)}`).join(', ');
                } else {
                    topCategories = `No expenses recorded in categories for ${latestMonthKey}.`;
                }
                return {
                    title: `Top Expense Categories for ${latestMonthKey}`,
                    categories: topCategories
                };
            }
            return {
                title: "Top Expense Categories",
                categories: topCategories
            };
        }
        presentationData.slide5 = getTopExpenseCategories();

        // Slide 6: Recent Transactions Summary (last 7 days)
        function getRecentTransactionsSummary() {
          const sevenDaysAgo = new Date(today);
          sevenDaysAgo.setDate(today.getDate() - 7);
          
          let recentTxCount = 0;
          let totalSpentLast7Days = 0;
          const recentSample = [];

          const sortedTransactions = [...globalAllTransactions].sort((a, b) => new Date(b.date) - new Date(a.date));

          sortedTransactions.forEach(tx => {
            const txDate = new Date(tx.date + "T00:00:00"); // Ensure correct date parsing
            if (txDate >= sevenDaysAgo) {
              recentTxCount++;
              if (tx.amount > 0) { // Expense
                totalSpentLast7Days += tx.amount;
              }
              if (recentSample.length < 3) { // Get last 3 transactions
                  recentSample.push(`${tx.date}: ${tx.description} (${tx.amount.toFixed(2)})`);
              }
            }
          });
          return {
            title: "Recent Transactions (Last 7 Days)",
            count: recentTxCount,
            totalSpent: totalSpentLast7Days.toFixed(2),
            sampleTransactions: recentSample.length > 0 ? recentSample.join('; ') : "No transactions in the last 7 days."
          };
        }
        presentationData.slide6 = getRecentTransactionsSummary();

        // Slide 7: Actionable Next Steps
        presentationData.slide7 = {
          title: "Actionable Next Steps",
          steps: [
            "Review spending patterns against budget goals.",
            "Identify top expense categories for potential savings.",
            "Monitor upcoming bills and payments.",
            "Consider setting new financial goals based on this overview."
            // These are generic; n8n agent could potentially generate more specific ones.
          ]
        };

        // Slide 8: Concluding Slide
        presentationData.slide8 = {
          title: "Thank You",
          message: "This financial overview was generated based on the available data."
        };
        
        return presentationData;
      }

      async function sendToN8N(data) {
        if (N8N_WEBHOOK_URL === "YOUR_N8N_WEBHOOK_URL_HERE" || !N8N_WEBHOOK_URL) {
          alert("N8N Webhook URL is not configured. Please update it in the script.");
          console.error("N8N Webhook URL is not configured.");
          return;
        }
        try {
          showProcessingBar("Generating presentation data...");
          const response = await fetch(N8N_WEBHOOK_URL, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
          });
          hideProcessingBar();
          if (response.ok) {
            alert('Presentation data sent to N8N successfully!');
            console.log('Data sent to N8N:', data);
          } else {
            const errorText = await response.text();
            alert(`Failed to send data to N8N. Status: ${response.status}. Details: ${errorText}`);
            console.error('Failed to send data to N8N:', response.status, errorText);
          }
        } catch (error) {
          hideProcessingBar();
          alert('Error sending data to N8N: ' + error.message);
          console.error('Error sending data to N8N:', error);
        }
      }

      const agentButton = document.getElementById('agent-action-button');
      if (agentButton) {
        agentButton.addEventListener('click', async () => {
          if (Object.keys(dailyActivity).length === 0 && globalAllTransactions.length === 0) {
            alert("No data available to generate a presentation. Please upload some files first.");
            return;
          }
          const dataForN8N = await generatePresentationData();
          await sendToN8N(dataForN8N);
        });
      }
      // --- End Presentation Generation Logic ---

      setupTimeframeControls(); // Call to initialize the new synchronized controls
    </script>
</body>
</html>