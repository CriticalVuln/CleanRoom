<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Personal Finance Tracker</title>

  <!-- Your original inline styles -->
  <style>
    /* Copied from Productivity Tracker */
    * { box-sizing: border-box; }
    body {
      background: #0D0B14; /* Darker background */
      color: #E0E0E0; /* Lighter default text */
      font-family: "Poppins", sans-serif;
      margin: 0;
      padding: 40px;
      display: flex;
      flex-direction: column; /* Stack nav button and content */
      align-items: center; /* Center content horizontally */
    }
    .app-container {
      width: 100%;
      max-width: 1000px; /* Adjust max-width as needed */
      background: #1A1625; /* Darker card background */
      border-radius: 12px;
      padding: 25px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      margin-top: 70px; /* Add space below the fixed nav button */
    }
    /* Copied from Productivity Tracker */
    .card {
      background: #1A1625; /* Darker card background */
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      margin-bottom: 24px; /* Add margin between cards */
    }
    /* Container for the chart to control its height */
    .chart-container {
      position: relative;
      /* height: 300px; */ /* Removed - height will be managed by inner container or content */
      /* margin-top: 12px; */ /* Removed - spacing managed by card padding and flex gap */
    }
    /* --- End Copied/Adapted Styles --- */

    h1 {
        color: #FFF; /* White heading */
        font-weight: 600;
        margin-bottom: 20px;
        text-align: center;
    }
    #csvPicker {
        display: block; /* Make it a block element */
        margin: 0 auto 20px auto; /* Center it and add bottom margin */
        padding: 10px;
        border: 1px solid #4F4B68; /* Darker border */
        border-radius: 4px;
        background: #211D30; /* Darker input background */
        color: #E0E0E0; /* Lighter text */
        cursor: pointer;
    }
    /* Style the file input button text */
    #csvPicker::file-selector-button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        background: #63FFDA; /* Accent Cyan/Turquoise */
        color: #0D0B14; /* Dark text for contrast */
        font-weight: 600;
        cursor: pointer;
        margin-right: 10px;
    }
    #total {
        text-align: center;
        font-size: 1.1em;
        color: #FFF; /* White text for total */
    }
    /* Copied from Productivity Tracker */
    .content {
      width: 100%;
      max-width: 1400px; /* Match Productivity Tracker app-container width */
      margin-top: 70px; /* Add space below the fixed nav button */
      /* Center the content container itself */
      margin-left: auto;
      margin-right: auto;
    }
    /* Sidebar styles (copied from Landing Page) */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 60px;
      background: #1A1625;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 20px;
    }
    .sidebar a {
      color: #63FFDA;
      font-size: 24px;
      margin: 16px 0;
      text-decoration: none;
    }
    .sidebar a svg {
      width: 24px;
      height: 24px;
      fill: none;
      stroke: #63FFDA;
      stroke-width: 2;
    }
    /* --- New: File History Tab Styles --- */
    .file-history-tab {
      position: absolute;
      top: 18px;
      left: 70px;
      background: #211D30;
      color: #63FFDA;
      border: none;
      border-radius: 8px 8px 0 0;
      padding: 8px 22px 8px 18px;
      font-family: 'Poppins', sans-serif;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      transition: background 0.15s, color 0.15s;
    }
    .file-history-tab.active {
      background: #63FFDA;
      color: #0D0B14;
    }
    .file-history-panel {
      position: absolute;
      top: 54px;
      left: 70px;
      background: #1A1625;
      color: #E0E0E0;
      border-radius: 0 0 12px 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      min-width: 320px;
      max-width: 420px;
      padding: 18px 18px 10px 18px;
      z-index: 1100;
      display: none;
    }
    .file-history-panel h3 {
      margin: 0 0 10px 0;
      font-size: 1.1em;
      color: #63FFDA;
      font-weight: 600;
    }
    .file-history-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 220px;
      overflow-y: auto;
    }
    .file-history-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 7px 0;
      border-bottom: 1px solid #29223a;
      font-size: 14px;
    }
    .file-history-list li:last-child { border-bottom: none; }
    .file-history-list .filename {
      flex: 1;
      color: #E0E0E0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .file-history-list .delete-btn {
      background: none;
      border: none;
      color: #FF6B6B;
      font-size: 15px;
      cursor: pointer;
      margin-left: 12px;
      padding: 2px 8px;
      border-radius: 4px;
      transition: background 0.15s;
    }
    .file-history-list .delete-btn:hover {
      background: #2a263a;
    }
    /* --- New: Category Chart Styles --- */
    /* .category-chart-container is now primarily styled by .card and .charts-row-container */
    /* Specific styles for h2, selector, and inner container remain if needed */
    .category-chart-container h2 {
      color: #FFF;
      font-weight: 600;
      margin-bottom: 15px;
      text-align: center;
      font-size: 1.2em;
    }
    .category-chart-inner-container {
      position: relative;
      height: 300px; /* Adjust as needed */
    }
    #categoryMonthSelector {
      display: block;
      margin: 15px auto 10px auto; /* Added bottom margin */
      padding: 8px;
      border: 1px solid #4F4B68;
      border-radius: 4px;
      background: #211D30;
      color: #E0E0E0;
      cursor: pointer;
    }

    /* --- New: Net Worth Chart Styles --- */
    .net-worth-container {
      /* Styles inherited from .card */
      margin-bottom: 24px; /* Space below this top widget */
    }
    .net-worth-container h2 {
      color: #63FFDA; /* Turquoise */
      font-weight: 600;
      margin-bottom: 15px;
      text-align: center;
      font-size: 1.2em;
    }
    .net-worth-chart-inner-container {
      position: relative;
      height: 250px; /* Adjust as needed, slightly smaller for a top widget */
    }

    /* --- Timeframe Controls --- */
    .timeframe-controls {
      text-align: center;
      margin-bottom: 15px;
    }
    .timeframe-controls button {
      background: none;
      border: none;
      color: #63FFDA; /* Turquoise */
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      padding: 5px 12px;
      border-radius: 6px;
      cursor: pointer;
      margin: 0 5px;
      font-size: 0.9em;
      transition: background-color 0.2s, color 0.2s;
    }
    .timeframe-controls button.active {
      background-color: #63FFDA;
      color: #0D0B14; /* Dark background for active button text */
    }
    .timeframe-controls button:hover:not(.active) {
      background-color: rgba(99, 255, 218, 0.1); /* Slight hover effect */
    }

    /* --- Rule for Expenses title --- */
    .chart-container > h2 {
      text-align: center;
      color: #63FFDA; /* Turquoise */
      font-weight: 600;
      margin-bottom: 15px;
      font-size: 1.2em;
    }

    /* --- New: Row container for side-by-side charts --- */
    .charts-row-container {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      gap: 24px; /* Space between cards in the row */
      margin-bottom: 24px; /* Add margin below the row */
    }
    .charts-row-container > .card {
      flex: 1 1 calc(50% - 12px); /* Grow, shrink, basis with gap adjustment */
      min-width: 300px; /* Minimum width before wrapping or shrinking too much */
      margin-bottom: 0; /* Remove bottom margin as gap handles spacing */
    }
    /* --- New: Inner container for Charges vs Payments chart --- */
    .charges-payments-chart-inner-container {
      position: relative;
      height: 350px; /* Adjusted from 325px */
    }

    /* --- New: Recent Transactions Widget --- */
    .recent-transactions-container {
      /* Styles inherited from .card */
      margin-top: 24px; /* Space above this widget */
    }
    .recent-transactions-container h2 {
      color: #63FFDA; /* Turquoise */
      font-weight: 600;
      margin-bottom: 15px;
      text-align: center;
      font-size: 1.2em;
    }
    .recent-transactions-table-container {
      max-height: 300px; /* Consistent height with other chart containers */
      overflow-y: auto;
      border: 1px solid #29223a; /* Subtle border */
      border-radius: 8px;
    }
    .recent-transactions-table {
      width: 100%;
      border-collapse: collapse;
    }
    .recent-transactions-table th,
    .recent-transactions-table td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid #29223a;
    }
    .recent-transactions-table th {
      background-color: #211D30; /* Darker header background */
      color: #E0E0E0;
      font-weight: 600;
      position: sticky; /* Keep headers visible on scroll */
      top: 0;
      z-index: 1;
    }
    .recent-transactions-table td {
      color: #C0C0C0; /* Slightly lighter than default for data */
    }
    .recent-transactions-table tr:last-child td {
      border-bottom: none;
    }
    .recent-transactions-table .amount-income {
      color: #63FFDA; /* Green for income/payments */
      font-weight: 500;
    }
    .recent-transactions-table .amount-expense {
      color: #FF6B6B; /* Red for charges/expenses */
      font-weight: 500;
    }
    /* Light mode styles for recent transactions */
    body.light-mode .recent-transactions-container h2 {
        color: #00796b; /* Darker teal for light mode */
    }
    body.light-mode .recent-transactions-table-container {
        border: 1px solid #D0D0D0;
    }
    body.light-mode .recent-transactions-table th {
        background-color: #E8E8E8;
        color: #333;
        border-bottom: 1px solid #C0C0C0;
    }
    body.light-mode .recent-transactions-table td {
        color: #555;
        border-bottom: 1px solid #D0D0D0;
    }
    body.light-mode .recent-transactions-table .amount-income {
        color: #00796b; /* Consistent green */
    }
    body.light-mode .recent-transactions-table .amount-expense {
        color: #d32f2f; /* Consistent red */
    }

    /* --- New: PDF Upload Modal Styles --- */
    .upload-modal {
      display: none; /* Hidden by default */
      position: fixed;
      z-index: 1500; /* Higher than file history panel */
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.6); /* Dim background */
      align-items: center; /* Vertical center */
      justify-content: center; /* Horizontal center */
    }

    .upload-modal-content {
      background-color: #1A1625; /* Dark card background */
      margin: auto;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.7);
      width: 90%;
      max-width: 550px; /* Max width for the modal */
      display: flex;
      flex-direction: column;
      gap: 20px; /* Space between elements */
    }

    .upload-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 15px;
      border-bottom: 1px solid #4F4B68; /* Separator line */
    }

    .upload-modal-header h2 {
      color: #E0E0E0;
      font-size: 1.4em;
      margin: 0;
    }

    .upload-modal-close-btn {
      color: #A0A0A0;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
    }
    .upload-modal-close-btn:hover,
    .upload-modal-close-btn:focus {
      color: #FFF;
    }

    .upload-area {
      border: 2px dashed #4F4B68; /* Dashed border */
      border-radius: 8px;
      padding: 40px 20px; /* More padding */
      text-align: center;
      cursor: pointer;
      background-color: #0D0B14; /* Slightly darker than modal content */
      transition: background-color 0.2s, border-color 0.2s;
    }
    .upload-area:hover {
      background-color: #211D30;
      border-color: #63FFDA;
    }
    .upload-area-icon {
      font-size: 40px; /* Larger icon */
      color: #63FFDA; /* Turquoise icon */
      margin-bottom: 15px;
    }
    .upload-area-text {
      color: #E0E0E0;
      font-size: 1.1em;
      margin-bottom: 8px;
    }
    .upload-area-subtext {
      color: #A0A0A0;
      font-size: 0.9em;
    }
    #modalPdfInput {
      display: none; /* Hide the actual input */
    }
    #selectedFilesList {
      margin-top: 15px;
      max-height: 100px;
      overflow-y: auto;
      font-size: 0.9em;
      color: #C0C0C0;
    }
    #selectedFilesList div {
      padding: 3px 0;
    }

    .upload-modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding-top: 15px;
      border-top: 1px solid #4F4B68; /* Separator line */
    }

    .upload-modal-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.95em;
      transition: background-color 0.2s, color 0.2s;
    }
    .upload-modal-btn.primary {
      background-color: #63FFDA; /* Turquoise */
      color: #0D0B14; /* Dark text */
    }
    .upload-modal-btn.primary:hover {
      background-color: #82ffe5;
    }
    .upload-modal-btn.secondary {
      background-color: #4F4B68; /* Darker grey */
      color: #E0E0E0;
    }
    .upload-modal-btn.secondary:hover {
      background-color: #5f5a7a;
    }

    /* --- New: Progress Bar Styles --- */
    #progressBarContainer {
      position: fixed; /* Make it fixed to the viewport */
      top: 0;
      left: 0;
      width: 100%;
      background-color: #0D0B14; /* Match body background for a seamless top bar */
      padding: 8px 0; /* Add some vertical padding */
      box-shadow: 0 2px 8px rgba(0,0,0,0.7); /* Add a shadow for depth */
      display: none; /* Hidden by default */
      z-index: 9999; /* Ensure it's on top of all other content */
      /* margin-top and margin-bottom are removed as they are not effective with fixed positioning */
    }

    #progressBar {
      width: 80%; /* Bar itself doesn't span full width */
      margin: 0 auto; /* Center the bar within the container */
      height: 20px; /* Adjusted height */
      background-color: #63FFDA; /* Accent Cyan/Turquoise */
      background-image: linear-gradient(
        45deg,
        rgba(13, 11, 20, 0.25) 25%, /* Darker stripes for contrast */
        transparent 25%,
        transparent 50%,
        rgba(13, 11, 20, 0.25) 50%,
        rgba(13, 11, 20, 0.25) 75%,
        transparent 75%,
        transparent
      );
      background-size: 40px 40px; /* Size of the stripes */
      border-radius: 5px;
      text-align: center;
      line-height: 20px; /* Match adjusted height */
      color: #0D0B14; /* Dark text for contrast on turquoise */
      font-weight: bold;
      animation: progressBarAnimation 2s linear infinite;
      transition: width 0.3s ease-in-out; /* Smooth width changes if you implement actual progress updates */
    }

    @keyframes progressBarAnimation {
      0% {
        background-position: 40px 0;
      }
      100% {
        background-position: 0 0;
      }
    }
  </style>

  <!-- Poppins font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <!-- ―――---- added helper libraries ----――― -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script> <!-- Chart.js UMD bundle :contentReference[oaicite:1]{index=1} -->
  <!-- ADDED: Date Adapter for Chart.js Time Scale -->
  <script src="https://cdn.jsdelivr.net/npm/date-fns@3.6.0/cdn.min.js"></script> <!-- date-fns library -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script> <!-- date-fns adapter -->
</head>
<body>
  <script src="config.js"></script> <!-- Load config first -->
  <button id="fileHistoryTab" class="file-history-tab">File History</button>
  <div id="fileHistoryPanel" class="file-history-panel">
    <h3>Uploaded Files</h3>
    <ul id="fileHistoryList" class="file-history-list"></ul>
  </div>
  <nav class="sidebar">
    <a href="Landing Page.html">
      <svg viewBox="0 0 24 24">
        <path d="M3 10L12 3l9 7v11a1 1 0 0 1-1 1h-6v-7h-4v7H4a1 1 0 0 1-1-1V10z"/>
      </svg>
    </a>
    <a href="Personal Finance Tracker.html">
      <svg viewBox="0 0 24 24">
        <polyline points="3 17 8 12 13 16 21 4" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </a>
    <a href="Productivity Tracker.html">
      <svg viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="9"/>
        <polyline points="12 7 12 12 15 15" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </a>
  </nav>

  <div class="content">
    <h1>Personal Finance Tracker</h1>
    <!-- Modified: This input will now trigger the modal. We'll hide its default appearance. -->
    <input id="pdfPicker" type="file" accept=".pdf" multiple style="display: none;">
    <!-- New Button to trigger the original pdfPicker input, which in turn will trigger the modal -->
    <button id="openPdfUploadModalBtn" class="upload-modal-btn primary" style="margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto;">Choose PDF Files</button>

    <div id="total"></div>

    <!-- New PDF Upload Modal -->
    <div id="pdfUploadModal" class="upload-modal">
      <div class="upload-modal-content">
        <div class="upload-modal-header">
          <h2>Upload PDF Statements</h2>
          <button id="closeUploadModalBtn" class="upload-modal-close-btn">&times;</button>
        </div>
        
        <label for="modalPdfInput" class="upload-area" id="uploadAreaLabel">
          <div class="upload-area-icon">&#x21E7;</div> <!-- Unicode UPWARDS ARROW -->
          <div class="upload-area-text">Drag & drop files or click to choose files</div>
          <div class="upload-area-subtext">Supported file types: PDF</div>
        </label>
        <input id="modalPdfInput" type="file" accept=".pdf" multiple>
        <div id="selectedFilesList">
          <!-- Selected files will be listed here -->
        </div>

        <div class="upload-modal-footer">
          <button id="cancelUploadBtn" class="upload-modal-btn secondary">Cancel</button>
          <button id="confirmUploadBtn" class="upload-modal-btn primary">Upload</button>
        </div>
      </div>
    </div>
    <!-- End New PDF Upload Modal -->


    <!-- New Net Worth (Monthly Income) Widget -->
    <div class="net-worth-container card">
      <h2>Net Worth</h2>
      <div class="timeframe-controls">
        <button data-chart="netWorth" data-range="day">Day</button>
        <button data-chart="netWorth" data-range="week">Week</button>
        <button data-chart="netWorth" data-range="month" class="active">Month</button>
        <button data-chart="netWorth" data-range="year">Year</button>
      </div>
      <div class="net-worth-chart-inner-container">
        <canvas id="netWorthChartCanvas"></canvas>
      </div>
    </div>

    <!-- Row container for side-by-side charts -->
    <div class="charts-row-container">
      <div class="chart-container card">
        <h2>Expenses</h2> <!-- Changed from Charges vs Payments, removed inline style -->
        <div class="timeframe-controls">
          <button data-chart="expenses" data-range="day">Day</button>
          <button data-chart="expenses" data-range="week">Week</button>
          <button data-chart="expenses" data-range="month" class="active">Month</button>
          <button data-chart="expenses" data-range="year">Year</button>
        </div>
        <div class="charges-payments-chart-inner-container"> <!-- NEW WRAPPER -->
          <canvas id="spendChart"></canvas>
        </div>
      </div>

      <div class="category-chart-container card"> <!-- Ensured .card class is present -->
        <select id="categoryMonthSelector"></select>
        <div class="category-chart-inner-container">
          <canvas id="categorySpendChart"></canvas>
        </div>
      </div>
    </div>

    <!-- New Recent Transactions Widget -->
    <div class="recent-transactions-container card">
      <h2>Recent Transactions</h2>
      <div class="recent-transactions-table-container">
        <table class="recent-transactions-table">
          <thead>
            <!-- Headers will be populated by JS or can be static if known -->
          </thead>
          <tbody id="recentTransactionsBody">
            <!-- Transactions will be populated here by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>

    <div id="progressBarContainer">
      <div id="progressBar">Processing...</div>
    </div>

    <script>
      // Helper to extract month/year from filename
      function extractMonthYearFromName(name) {
        if (typeof name !== 'string') return null;
        const trimmedName = name.trim();

        const monthMap = {
          jan: 1, january: 1, feb: 2, february: 2, mar: 3, march: 3, apr: 4, april: 4,
          may: 5, jun: 6, june: 6, jul: 7, july: 7, aug: 8, august: 8, sep: 9, september: 9,
          oct: 10, october: 10, nov: 11, november: 11, dec: 12, december: 12
        };
        const monthPattern = '(January|Jan|February|Feb|March|Mar|April|Apr|May|June|Jun|July|Jul|August|Aug|September|Sep|Oct|October|November|Nov|December|Dec)';

        // Try to match "Month YYYY" (e.g., "March 2025")
        // User stated format: "Month Year Bank Statement"
        const textualMatchMonthYear = trimmedName.match(new RegExp(monthPattern + '\\s+(\\d{4})', 'i'));

        if (textualMatchMonthYear && textualMatchMonthYear[1] && textualMatchMonthYear[2]) {
          const monthName = textualMatchMonthYear[1].toLowerCase();
          const year = parseInt(textualMatchMonthYear[2], 10);
          const month = monthMap[monthName];
          if (month && year >= 1900 && year <= 2100) { // Added year range check
            return { year, month };
          }
        }

        // Fallback: Try to match "YYYY Month" (less common for user's stated format)
        const textualMatchYearMonth = trimmedName.match(new RegExp('(\\d{4})\\s+' + monthPattern, 'i'));
         if (textualMatchYearMonth && textualMatchYearMonth[1] && textualMatchYearMonth[2]) {
          const year = parseInt(textualMatchYearMonth[1], 10);
          const monthName = textualMatchYearMonth[2].toLowerCase();
          const month = monthMap[monthName];
          if (month && year >= 1900 && year <= 2100) {
            return { year, month };
          }
        }

        // Fallback to numeric month and year (e.g., "2025-03", "2025_3")
        const numericDateMatch = trimmedName.match(/(\\d{4})[-_]?([0-1]?[0-9])/);
        if (numericDateMatch && numericDateMatch[1] && numericDateMatch[2]) {
          const year = parseInt(numericDateMatch[1], 10);
          const month = parseInt(numericDateMatch[2], 10);
          if (year >= 1900 && year <= 2100 && month >= 1 && month <= 12) {
            return { year, month };
          }
        }
        console.warn('Could not extract month/year from filename:', name); // Added warning
        return null;
      }
      let chart = null;
      // Global aggregates - moving to daily structure
      // let monthlyNet = {}; // Old
      // let monthlyCharges = {}; // Old
      // let monthlyPayments = {}; // Old
      // let monthlyDCIncome = {}; // Old
      // let totalCharges = 0; // Old - will be derived if needed
      // let totalPayments = 0; // Old - will be derived

      let dailyActivity = {}; // New: {"YYYY-MM-DD": {charges: 0, payments: 0, dcIncome: 0, categories: {"Groceries": 0,...}}}
      let globalAllTransactions = []; // New: To store all individual transactions

      // --- New: Category Spending Globals ---
      // let monthlyCategorizedSpending = {}; // Old - merged into dailyActivity
      let categoryChart = null;
      const CATEGORIES = ["Groceries", "Food Delivery/Restaurant", "Gas", "Misc", "Other"];

      // --- New: Net Worth (Income) Chart Global ---
      let netWorthChartInstance = null;
      let expensesChartTimeframe = 'month'; // Default timeframe for expenses chart
      let netWorthChartTimeframe = 'month'; // Default timeframe for net worth chart

      // API Key will now be loaded from config.js
      const GEMINI_API_KEY = window.APP_CONFIG && window.APP_CONFIG.GEMINI_API_KEY;

      // --- File History State ---
      let fileHistory = JSON.parse(localStorage.getItem('financeFileHistory') || '[]');
      // --- File-to-Month Mapping for Robust Deletion ---
      // let fileMonthMap = JSON.parse(localStorage.getItem('financeFileMonthMap') || '{}'); // Old
      let fileDataKeysMap = JSON.parse(localStorage.getItem('financeFileDataKeysMap') || '{}'); // New: {"filename": ["YYYY-MM-DD", ...]}
      let globalAllTransactionsStorageKey = 'financeGlobalAllTransactions'; // New

      // --- Progress Bar Logic ---
      // Call showProcessingBar() when your file processing starts.
      // Call hideProcessingBar() when your file processing ends (in a finally block if applicable).
      // If you have an existing element that shows a text message (e.g., <div id="status"></div>),
      // replace 'yourStatusMessageElementId' with its actual ID to hide it when the bar is shown.
      // If you don't have one, you can remove the lines related to 'originalStatusElement'.

      const progressBarContainer = document.getElementById('progressBarContainer');
      const progressBar = document.getElementById('progressBar');
      // const originalStatusElement = document.getElementById('yourStatusMessageElementId'); // Optional: Replace ID

      function showProcessingBar(message = "Processing file...") {
        // if (originalStatusElement) {
        //   originalStatusElement.style.display = 'none'; // Hide the old text message
        // }
        if (progressBarContainer && progressBar) {
          progressBar.textContent = message;
          progressBarContainer.style.display = 'block';
        }
      }

      function hideProcessingBar() {
        if (progressBarContainer) {
          progressBarContainer.style.display = 'none';
        }
        // if (originalStatusElement) {
        //   originalStatusElement.style.display = 'block'; // Or whatever the default state should be
        //   originalStatusElement.textContent = ''; // Clear it or set to a success/failure message
        // }
      }
      // --- End Progress Bar Logic ---


      function saveFileDataKeysMap() { // New name
        localStorage.setItem('financeFileDataKeysMap', JSON.stringify(fileDataKeysMap));
      }

      // --- File History UI Logic ---
      const fileHistoryTab = document.getElementById('fileHistoryTab');
      const fileHistoryPanel = document.getElementById('fileHistoryPanel');
      const fileHistoryList = document.getElementById('fileHistoryList');

      function renderFileHistory() {
        fileHistoryList.innerHTML = '';
        if (!fileHistory.length) {
          fileHistoryList.innerHTML = '<li style="color:#A0A0A0;">No files uploaded yet.</li>';
          return;
        }

        // Sort fileHistory by date (year, then month), then by name for undated files
        fileHistory.sort((a, b) => {
          const dateA = extractMonthYearFromName(a.name);
          const dateB = extractMonthYearFromName(b.name);

          if (dateA && dateB) {
            if (dateA.year !== dateB.year) {
              return dateA.year - dateB.year; // Sort by year ascending
            }
            return dateA.month - dateB.month; // Then by month ascending
          } else if (dateA) {
            return -1; // dateA (has date) comes before dateB (no date)
          } else if (dateB) {
            return 1;  // dateB (has date) comes before dateA (no date)
          } else {
            // Neither has a parseable date, sort by name alphabetically
            return a.name.localeCompare(b.name);
          }
        });

        fileHistory.forEach(f => {
          const li = document.createElement('li');
          const nameSpan = document.createElement('span');
          nameSpan.className = 'filename';
          nameSpan.textContent = f.name;
          const delBtn = document.createElement('button');
          delBtn.className = 'delete-btn';
          delBtn.textContent = 'Delete';
          delBtn.onclick = (event) => { // Add event parameter
            event.stopPropagation(); // Stop the click from bubbling to the document
            deleteFileHistory(f.name);
          };
          li.appendChild(nameSpan);
          li.appendChild(delBtn);
          fileHistoryList.appendChild(li);
        });
      }

      function showFileHistory(show) {
        if (show) {
          fileHistoryPanel.style.display = 'block';
          fileHistoryTab.classList.add('active');
          renderFileHistory();
        } else {
          fileHistoryPanel.style.display = 'none';
          fileHistoryTab.classList.remove('active');
        }
      }
      fileHistoryTab.addEventListener('click', () => {
        showFileHistory(fileHistoryPanel.style.display !== 'block');
      });
      document.addEventListener('click', e => {
        if (!fileHistoryPanel.contains(e.target) && e.target !== fileHistoryTab) {
          showFileHistory(false);
        }
      });

      function addFileToHistory(name, keys) { // keys are now YYYY-MM-DD
        if (!fileHistory.some(f => f.name === name)) {
          fileHistory.push({ name });
          localStorage.setItem('financeFileHistory', JSON.stringify(fileHistory));
        }
        if (Array.isArray(keys) && keys.length) {
          fileDataKeysMap[name] = keys; // Store daily keys
          saveFileDataKeysMap();
        }
      }
      function deleteFileHistory(name) {
        // Remove from fileHistory
        fileHistory = fileHistory.filter(f => f.name !== name);
        localStorage.setItem('financeFileHistory', JSON.stringify(fileHistory));
        // Remove all data from this file from the charts
        removeFileData(name); // Uses daily keys now
        // Remove mapping
        delete fileDataKeysMap[name];
        saveFileDataKeysMap();
        renderFileHistory();
        // updateDisplay(); // Will be called by updateAndSaveData
        updateAndSaveData();
      }

      // --- New: Helper function to rebuild dailyActivity from globalAllTransactions for specific dates ---
      function rebuildDailyActivityForDates(dateKeysToRebuild) {
        const dates = Array.isArray(dateKeysToRebuild) ? dateKeysToRebuild : Array.from(dateKeysToRebuild);

        dates.forEach(dateKey => {
          // Initialize/clear the specific day's activity
          dailyActivity[dateKey] = { charges: 0, payments: 0, dcIncome: 0, categories: {} };
          CATEGORIES.forEach(cat => dailyActivity[dateKey].categories[cat] = 0); // Ensure all categories are initialized for summing up
        });

        globalAllTransactions.forEach(tx => {
          if (dates.includes(tx.date)) { // Process only if the transaction's date is one we're rebuilding
            const dateKey = tx.date;
            const amount = parseFloat(tx.amount); // Amount is stored as parsed: positive for charge, negative for income/payment
            const isDCFile = tx.sourceFile.toUpperCase().startsWith("DC");

            if (!dailyActivity[dateKey]) { // Should not happen if initialized above, but as a safeguard
              dailyActivity[dateKey] = { charges: 0, payments: 0, dcIncome: 0, categories: {} };
              CATEGORIES.forEach(cat => dailyActivity[dateKey].categories[cat] = 0);
            }

            if (isDCFile) {
              if (amount < 0) { // DC income is stored as negative by parser, dcIncome in dailyActivity is positive
                dailyActivity[dateKey].dcIncome += Math.abs(amount);
              }
            } else { // Not a DC file
              if (amount > 0) { // Charge
                dailyActivity[dateKey].charges += amount;
                let categoryToApply = "Other"; // Default category
                if (tx.category && CATEGORIES.includes(tx.category)) {
                  categoryToApply = tx.category;
                }
                dailyActivity[dateKey].categories[categoryToApply] = (dailyActivity[dateKey].categories[categoryToApply] || 0) + amount;
              } else if (amount < 0) { // Payment
                dailyActivity[dateKey].payments += Math.abs(amount);
              }
            }
          }
        });

        // Clean up days that ended up with no activity after rebuild
        dates.forEach(dateKey => {
          const dayData = dailyActivity[dateKey];
          if (dayData) { // Check if dayData exists, as it might have been deleted by another process if code changes
            let isEmpty = dayData.charges === 0 && dayData.payments === 0 && dayData.dcIncome === 0;
            if (isEmpty) {
              let categoriesSum = 0;
              CATEGORIES.forEach(cat => categoriesSum += (dayData.categories[cat] || 0));
              if (categoriesSum === 0) {
                delete dailyActivity[dateKey];
              }
            }
          }
        });
      }

      function removeFileData(name) {
        const dailyKeysAffectedByThisFile = fileDataKeysMap[name] || [];

        // Remove transactions from globalAllTransactions associated with this file
        globalAllTransactions = globalAllTransactions.filter(tx => tx.sourceFile !== name);
        localStorage.setItem(globalAllTransactionsStorageKey, JSON.stringify(globalAllTransactions));

        // After removing transactions, rebuild dailyActivity for the dates this file affected
        if (dailyKeysAffectedByThisFile.length > 0) {
          rebuildDailyActivityForDates(dailyKeysAffectedByThisFile);
        }
        
        // fileDataKeysMap[name] will be deleted by deleteFileHistory function
        // Totals are recalculated in updateDisplay based on remaining dailyActivity
      }

      // --- On load, render file history ---
      renderFileHistory();
      showFileHistory(false);

      // Update totals display and chart
      function updateDisplay() {
        // Clear numeric summary
        document.getElementById('total').innerHTML = '';

        renderSpendChart(expensesChartTimeframe); // Pass current timeframe

        // localStorage.setItem('financeData', JSON.stringify({ monthlyCharges, monthlyPayments, monthlyDCIncome, totalCharges, totalPayments })); // Old
        // localStorage.setItem('financeCategorizedData', JSON.stringify(monthlyCategorizedSpending)); // Old

        localStorage.setItem('financeDailyActivity', JSON.stringify(dailyActivity)); // New: Save all daily activity
        localStorage.setItem(globalAllTransactionsStorageKey, JSON.stringify(globalAllTransactions)); // New: Save all transactions

        // Update and render category chart
        populateCategoryMonthSelector();
        const selectedMonthForCategory = document.getElementById('categoryMonthSelector').value;
        renderCategoriesChart(selectedMonthForCategory);

        // Update and render Net Worth (Income) chart
        renderNetWorthChart(netWorthChartTimeframe); // Pass current timeframe

        renderRecentTransactions(); // New: Render recent transactions
      }

      // --- New: Update and Save all data ---
      function updateAndSaveData() {
        updateDisplay(); // This now handles saving all primary data to localStorage
        // fileMonthMap is saved by its own function saveFileMonthMap()
      }


      // --- New: Render Recent Transactions ---
      function renderRecentTransactions() {
        const tbody = document.getElementById('recentTransactionsBody');
        tbody.innerHTML = ''; // Clear existing rows

        if (globalAllTransactions.length === 0) {
          const tr = tbody.insertRow();
          const td = tr.insertCell();
          td.colSpan = 5;
          td.textContent = 'No transactions to display yet.';
          td.style.textAlign = 'center';
          td.style.color = '#A0A0A0';
          return;
        }

        // Sort transactions by date, most recent first
        const sortedTransactions = [...globalAllTransactions].sort((a, b) => new Date(b.date) - new Date(a.date));
        
        const recentTransactions = sortedTransactions.slice(0, 10);

        recentTransactions.forEach(tx => {
          const tr = tbody.insertRow();
          
          const dateCell = tr.insertCell();
          dateCell.textContent = tx.date;

          const descCell = tr.insertCell();
          descCell.textContent = tx.description;
          
          const categoryCell = tr.insertCell();
          categoryCell.textContent = tx.category || 'N/A';

          const amountCell = tr.insertCell();
          amountCell.textContent = parseFloat(tx.amount).toFixed(2);
          // Amounts from parser: positive for charges/expenses, negative for income/payments
          if (tx.amount < 0) { // Income or Payment
            amountCell.className = 'amount-income';
            amountCell.textContent = Math.abs(parseFloat(tx.amount)).toFixed(2); // Display as positive
          } else { // Charge or Expense
            amountCell.className = 'amount-expense';
          }
          
          const sourceCell = tr.insertCell();
          sourceCell.textContent = tx.sourceFile;
          sourceCell.style.fontSize = '0.85em';
          sourceCell.style.color = '#888';
        });
      }


      // --- New: Category Chart Functions ---
      function populateCategoryMonthSelector() {
        const selector = document.getElementById('categoryMonthSelector');
        const currentSelection = selector.value; // Expects YYYY-MM
        selector.innerHTML = ''; // Clear existing options

        const availableMonths = new Set();
        Object.keys(dailyActivity).forEach(dateKey_YYYY_MM_DD => {
            availableMonths.add(dateKey_YYYY_MM_DD.substring(0, 7)); // Extract YYYY-MM
        });
        
        const sortedMonths = Array.from(availableMonths).sort().reverse(); // Latest first

        if (sortedMonths.length === 0) {
            const option = document.createElement('option');
            option.value = "";
            option.textContent = "No category data";
            selector.appendChild(option);
            selector.disabled = true;
            return;
        }

        selector.disabled = false;
        sortedMonths.forEach(monthKey_YYYY_MM => { // monthKey is YYYY-MM
            const option = document.createElement('option');
            option.value = monthKey_YYYY_MM;
            const [year, monthNum] = monthKey_YYYY_MM.split('-');
            const monthName = new Date(year, parseInt(monthNum) - 1, 1).toLocaleString('default', { month: 'long' });
            option.textContent = `${monthName} ${year}`;
            selector.appendChild(option);
        });

        if (sortedMonths.includes(currentSelection)) {
            selector.value = currentSelection;
        } else if (sortedMonths.length > 0) {
            selector.value = sortedMonths[0]; // Default to the latest month
        }
      }

      document.getElementById('categoryMonthSelector').addEventListener('change', (event) => {
        renderCategoriesChart(event.target.value); // Value is YYYY-MM
      });

      function renderCategoriesChart(monthKey_YYYY_MM) { // Expects YYYY-MM
        const container = document.querySelector('.category-chart-inner-container');
        container.innerHTML = '<canvas id="categorySpendChart"></canvas>'; // Ensure fresh canvas
        const ctx = document.getElementById('categorySpendChart').getContext('2d');

        if (categoryChart) {
            categoryChart.destroy();
        }

        if (!monthKey_YYYY_MM || !/^\d{4}-\d{2}$/.test(monthKey_YYYY_MM)) { // Validate monthKey format
            ctx.font = "16px Poppins";
            ctx.fillStyle = "#A0A0A0";
            ctx.textAlign = "center";
            ctx.fillText(monthKey_YYYY_MM ? "Invalid period format" : "Select a period", container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }
        
        const aggregatedCategoriesForMonth = {};
        CATEGORIES.forEach(cat => aggregatedCategoriesForMonth[cat] = 0); // Initialize all categories to 0

        let foundDataForMonth = false;
        Object.keys(dailyActivity).forEach(dateKey_YYYY_MM_DD => {
            if (dateKey_YYYY_MM_DD.startsWith(monthKey_YYYY_MM)) { // Check if the date belongs to the selected month
                const dayData = dailyActivity[dateKey_YYYY_MM_DD];
                if (dayData && dayData.categories) {
                    foundDataForMonth = true;
                    CATEGORIES.forEach(cat => {
                        if (dayData.categories[cat]) {
                            aggregatedCategoriesForMonth[cat] += dayData.categories[cat];
                        }
                    });
                }
            }
        });

        if (!foundDataForMonth) {
            ctx.font = "16px Poppins";
            ctx.fillStyle = "#A0A0A0";
            ctx.textAlign = "center";
            ctx.fillText("No category data for selected period", container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }

        const labels = CATEGORIES;
        const rawData = labels.map(cat => aggregatedCategoriesForMonth[cat] || 0);

        const filteredLabels = [];
        const filteredData = [];
        labels.forEach((label, index) => {
            if (rawData[index] > 0) {
                filteredLabels.push(label);
                filteredData.push(rawData[index]);
            }
        });

        if (filteredData.length === 0) {
            ctx.font = "16px Poppins";
            ctx.fillStyle = "#A0A0A0";
            ctx.textAlign = "center";
            ctx.fillText("No spending in categories for " + monthKey_YYYY_MM, container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }
        
        const [year, monthNum] = monthKey_YYYY_MM.split('-');
        const monthName = new Date(year, monthNum - 1, 1).toLocaleString('default', { month: 'long' });
        const chartTitle = `Spending Categories for ${monthName} ${year}`;


        categoryChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: filteredLabels,
                datasets: [{
                    label: 'Spending by Category',
                    data: filteredData,
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.7)', // Groceries
                        'rgba(54, 162, 235, 0.7)', // Food Delivery/Restaurant
                        'rgba(255, 206, 86, 0.7)', // Gas
                        'rgba(75, 192, 192, 0.7)', // Bills
                        'rgba(153, 102, 255, 0.7)', // Other
                        'rgba(255, 159, 64, 0.7)'  // Extra color
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(75, 192, 192, 1)',
                        'rgba(153, 102, 255, 1)',
                        'rgba(255, 159, 64, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { color: '#E0E0E0' }
                    },
                    title: {
                        display: true,
                        text: chartTitle,
                        color: '#E0E0E0',
                        font: { size: 16 }
                    }
                }
            }
        });
      }


      // --- New: Net Worth (Monthly Income) Chart Function ---
      function renderNetWorthChart(timeframe = 'month') {
        const canvas = document.getElementById('netWorthChartCanvas');
        if (!canvas) return; // Ensure canvas exists
        const ctx = canvas.getContext('2d');
        
        if (netWorthChartInstance) {
            netWorthChartInstance.destroy();
        }

        const { labels: incomeDays, data: incomeData } = aggregateDataForChart(dailyActivity, timeframe, 'dcIncome');

        const container = document.querySelector('.net-worth-chart-inner-container');
        if (incomeDays.length === 0) {
            // Clear previous chart content and display a message
            container.innerHTML = '<canvas id="netWorthChartCanvas"></canvas>'; // Re-add canvas
            const newCtx = document.getElementById('netWorthChartCanvas').getContext('2d');
            newCtx.font = "16px Poppins";
            newCtx.fillStyle = "#A0A0A0";
            newCtx.textAlign = "center";
            newCtx.fillText("Net Worth data from 'DC' files will appear here.", container.offsetWidth / 2, container.offsetHeight / 2);
            return;
        }
        
        // Create gradient for the line chart fill
        const gradientGreen = ctx.createLinearGradient(0, 0, 0, container.offsetHeight); // Adjust gradient height if needed
        gradientGreen.addColorStop(0, 'rgba(76, 255, 76, 0.4)'); // Green with 40% opacity
        gradientGreen.addColorStop(1, 'rgba(76, 255, 76, 0)');   // Green with 0% opacity

        netWorthChartInstance = new Chart(ctx, {
          type: 'line', 
          data: {
            labels: incomeDays.map(dateKey => { // Format YYYY-MM-DD to Month Day
                const [year, monthNum, dayNum] = dateKey.split('-');
                // return new Date(year, parseInt(monthNum) - 1, parseInt(dayNum)).toLocaleDateString('default', { month: 'short', day: 'numeric' });
                return `${monthNum.padStart(2, '0')}/${dayNum.padStart(2, '0')}`; // MM/DD format
            }),
            datasets: [
              {
                label: 'Net Worth (Income from DC files)', // Updated label
                data: incomeData,
                backgroundColor: gradientGreen, // Apply gradient fill
                borderColor: '#4CFF4C', // Green line
                borderWidth: 2, // Line thickness
                fill: true, // Enable fill
                tension: 0.4, // Smooth curve
                pointRadius: 4, // Size of the points
                pointBackgroundColor: '#4CFF4C', // Green points
                pointBorderColor: '#1A1625', // Match card background for point border
                pointHoverRadius: 7, // Size of points on hover
                pointHoverBackgroundColor: '#4CFF4C',
                pointHoverBorderColor: '#FFF' 
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { 
                grid: { color: '#333' }, 
                ticks: { 
                    color: '#ccc',
                    // autoSkip: true, // May be useful for many data points
                    // maxTicksLimit: 20 // Adjust as needed
                } 
              },
              y: { grid: { color: '#333' }, ticks: { color: '#ccc' }, beginAtZero: true }
            },
            plugins: {
              legend: { display: true, labels: { color: '#E0E0E0' } },
              title: {
                display: false, // Main title is in H2
                // text: 'Monthly Income Over Time', // Already have H2
                color: '#E0E0E0'
              }
            }
          }
        });
      }

      // --- New: Aggregate data for charts based on timeframe ---
      function aggregateDataForChart(sourceData, timeframe, dataType) {
        const now = new Date();
        let labels = [];
        let data = [];
        const aggregated = {}; // Temp object to sum data for periods

        const allSortedDates = Object.keys(sourceData).sort();

        allSortedDates.forEach(dateKey => {
          const entry = sourceData[dateKey];
          const value = entry ? (entry[dataType] || 0) : 0;
          if (value === 0 && dataType === 'dcIncome') return; // For net worth, skip if no income

          const date = new Date(dateKey + 'T00:00:00'); // Ensure local timezone interpretation

          let periodKey = '';

          if (timeframe === 'day') {
            periodKey = dateKey; // YYYY-MM-DD
          } else if (timeframe === 'week') {
            const weekStart = new Date(date);
            weekStart.setDate(date.getDate() - date.getDay()); // Sunday
            periodKey = `${weekStart.getFullYear()}-${(weekStart.getMonth() + 1).toString().padStart(2, '0')}-${weekStart.getDate().toString().padStart(2, '0')}`;
          } else if (timeframe === 'month') {
            periodKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
          } else if (timeframe === 'year') {
            periodKey = date.getFullYear().toString();
          }

          if (periodKey) {
            aggregated[periodKey] = (aggregated[periodKey] || 0) + value;
          }
        });

        labels = Object.keys(aggregated).sort();
        data = labels.map(key => aggregated[key]);
        
        // Format labels for display
        const formattedLabels = labels.map(label => {
            if (timeframe === 'day') {
                const [y, m, d] = label.split('-');
                return `${m}/${d}`;
            }
            if (timeframe === 'week') {
                 const [y, m, d] = label.split('-');
                return `Wk ${m}/${d}`;
            }
            if (timeframe === 'month') {
                const [y,m] = label.split('-');
                return new Date(y, parseInt(m)-1, 1).toLocaleString('default', { month: 'short' });
            }
            if (timeframe === 'year') {
                return label;
            }
            return label;
        });

        return { labels: formattedLabels, data };
      }

      // --- Modified: renderSpendChart to accept timeframe ---
      function renderSpendChart(timeframe = 'month') {
        const { labels: chartLabels, data: chargesData } = aggregateDataForChart(dailyActivity, timeframe, 'charges');
        const { data: paymentsData } = aggregateDataForChart(dailyActivity, timeframe, 'payments'); // Labels will be the same

        if (chart) chart.destroy();
        chart = new Chart(document.getElementById('spendChart'), {
          type: 'bar',
          data: {
            labels: chartLabels,
            datasets: [
              {
                label: 'Charges',
                data: chargesData,
                backgroundColor: '#FF4C4C',
                borderColor: '#1A1625',
                borderWidth: 1
              },
              {
                label: 'Payments',
                data: paymentsData,
                backgroundColor: '#4CFF4C',
                borderColor: '#1A1625',
                borderWidth: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                grid: { color: '#333' },
                ticks: { color: '#ccc' }
              },
              y: { grid: { color: '#333' }, ticks: { color: '#ccc' }, beginAtZero: true }
            },
            plugins: {
              legend: { labels: { color: '#E0E0E0' } },
              title: { display: false, text: 'Expenses Over Time', color: '#E0E0E0' }
            }
          }
        });
      }

      // --- Event Listeners for Timeframe Controls ---
      document.querySelectorAll('.timeframe-controls button').forEach(button => {
        button.addEventListener('click', () => {
          const chartName = button.dataset.chart;
          const range = button.dataset.range;

          // Remove active class from all buttons in this group
          button.parentElement.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
          // Add active class to the clicked button
          button.classList.add('active');

          if (chartName === 'expenses') {
            expensesChartTimeframe = range;
            renderSpendChart(expensesChartTimeframe);
          } else if (chartName === 'netWorth') {
            netWorthChartTimeframe = range;
            renderNetWorthChart(netWorthChartTimeframe);
          }
        });
      });

      // On load, restore saved data
      document.addEventListener('DOMContentLoaded', () => {
        const savedDailyActivity = localStorage.getItem('financeDailyActivity');
        if (savedDailyActivity) {
          dailyActivity = JSON.parse(savedDailyActivity);
        } else {
          dailyActivity = {}; // Initialize if nothing is saved
        }

        const savedGlobalTransactions = localStorage.getItem(globalAllTransactionsStorageKey);
        if (savedGlobalTransactions) {
          globalAllTransactions = JSON.parse(savedGlobalTransactions);
        } else {
          globalAllTransactions = [];
        }

        // fileHistory is already loaded at the top
        const savedFileDataKeysMap = localStorage.getItem('financeFileDataKeysMap');
        if (savedFileDataKeysMap) {
          fileDataKeysMap = JSON.parse(savedFileDataKeysMap);
        } else {
          fileDataKeysMap = {}; // Initialize if nothing is saved
        }

        updateDisplay(); // Call once after all data is loaded
      });

      // --- New: PDF Upload Modal Logic ---
      const pdfUploadModal = document.getElementById('pdfUploadModal');
      const openPdfUploadModalBtn = document.getElementById('openPdfUploadModalBtn');
      const closeUploadModalBtn = document.getElementById('closeUploadModalBtn');
      const modalPdfInput = document.getElementById('modalPdfInput');
      const uploadAreaLabel = document.getElementById('uploadAreaLabel');
      const selectedFilesList = document.getElementById('selectedFilesList');
      const confirmUploadBtn = document.getElementById('confirmUploadBtn');
      const cancelUploadBtn = document.getElementById('cancelUploadBtn');
      const originalPdfPicker = document.getElementById('pdfPicker'); // The original, now hidden, input

      let filesToUploadModal = []; // Renamed to avoid conflict

      if (openPdfUploadModalBtn) {
        openPdfUploadModalBtn.onclick = () => {
          pdfUploadModal.style.display = 'flex';
          filesToUploadModal = []; // Reset on open
          updateSelectedFilesListModal(); // Renamed to avoid conflict
        };
      }

      if (closeUploadModalBtn) {
        closeUploadModalBtn.onclick = () => {
          pdfUploadModal.style.display = 'none';
        };
      }

      if (cancelUploadBtn) {
        cancelUploadBtn.onclick = () => {
          pdfUploadModal.style.display = 'none';
        };
      }

      if (modalPdfInput) {
        modalPdfInput.onchange = (e) => {
          const newFiles = Array.from(e.target.files);
          newFiles.forEach(file => {
            if (file.type === "application/pdf" && !filesToUploadModal.some(existingFile => existingFile.name === file.name && existingFile.size === file.size)) {
              filesToUploadModal.push(file);
            }
          });
          updateSelectedFilesListModal(); 
          modalPdfInput.value = ''; // Clear input to allow re-selecting/re-adding the same file if needed
        };
      }

      function updateSelectedFilesListModal() { // Renamed to avoid conflict
        if (!selectedFilesList) return;
        selectedFilesList.innerHTML = '';
        if (filesToUploadModal.length === 0) {
          selectedFilesList.innerHTML = '<div>No files selected.</div>';
        } else {
          filesToUploadModal.forEach(file => {
            const fileDiv = document.createElement('div');
            fileDiv.textContent = file.name;
            selectedFilesList.appendChild(fileDiv);
          });
        }
        if (confirmUploadBtn) confirmUploadBtn.disabled = filesToUploadModal.length === 0;
      }

      if (confirmUploadBtn) {
        confirmUploadBtn.onclick = async () => {
          if (filesToUploadModal.length > 0) {
            showProcessingBar("Preparing to upload..."); // Show progress bar
            pdfUploadModal.style.display = 'none';
            const dataTransfer = new DataTransfer();
            filesToUploadModal.forEach(file => dataTransfer.items.add(file));
            if (originalPdfPicker) originalPdfPicker.files = dataTransfer.files;
            
            const event = new Event('change', { bubbles: true });
            if (originalPdfPicker) originalPdfPicker.dispatchEvent(event);
          }
        };
      }

      // Close modal if user clicks outside of it
      window.onclick = (event) => {
        if (event.target == pdfUploadModal) {
          pdfUploadModal.style.display = 'none';
        }
      };

      // Drag and drop functionality for the upload area
      if (uploadAreaLabel) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          uploadAreaLabel.addEventListener(eventName, preventDefaultsModal, false); // Renamed to avoid conflict
        });

        function preventDefaultsModal(e) { // Renamed to avoid conflict
          e.preventDefault();
          e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
          uploadAreaLabel.addEventListener(eventName, () => uploadAreaLabel.classList.add('hover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
          uploadAreaLabel.addEventListener(eventName, () => uploadAreaLabel.classList.remove('hover'), false);
        });

        uploadAreaLabel.addEventListener('drop', (e) => {
          const dt = e.dataTransfer;
          const droppedFiles = Array.from(dt.files).filter(file => file.type === "application/pdf");
          
          if (droppedFiles.length > 0) {
              droppedFiles.forEach(file => {
                if (!filesToUploadModal.some(existingFile => existingFile.name === file.name && existingFile.size === file.size)) {
                  filesToUploadModal.push(file);
                }
              });
              updateSelectedFilesListModal(); 
          } else if (dt.files.length > 0) {
              alert("Please drop PDF files only.");
          }
          if (modalPdfInput) modalPdfInput.value = ''; 
        }, false);
      }

      // --- Event Listener for File Picker (supports multiple) ---
      // Ensure originalPdfPicker exists before adding event listener
      if (originalPdfPicker) {
        originalPdfPicker.addEventListener('change', async e => { 
          const files = Array.from(e.target.files); // These are the files confirmed from the modal
          if (!files.length) {
            hideProcessingBar(); // Hide if no files somehow
            return;
          }

          // const h1Title = document.querySelector('.content h1'); // No longer needed
          // const originalPageTitle = h1Title ? h1Title.textContent : 'Personal Finance Tracker'; // No longer needed

          if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY_HERE') { // Check if key is missing or is the placeholder
            alert("Gemini API key is not set or is invalid. Please create config.js with your key (see config.js.example for GEMINI_API_KEY) and ensure it is loaded.");
            e.target.value = null; // Clear the file input
            hideProcessingBar(); // Hide progress bar on error
            return;
          }

          // if (h1Title) h1Title.textContent = `Processing ${files.length} file(s)...`; // Replaced by progress bar
          showProcessingBar(`Processing ${files.length} file(s)...`); // Show progress bar

          try {
            for (let i = 0; i < files.length; i++) {
              const f = files[i];
              const fileName = f.name;
              const fileExtension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();

              // if (h1Title) h1Title.textContent = `Processing ${fileName} (${i + 1} of ${files.length})...`; // Replaced by progress bar
              showProcessingBar(`Processing ${fileName} (${i + 1} of ${files.length})...`); // Update progress bar message

              if (fileExtension === 'pdf') {
                try {
                  await handlePdfFile(f); 
                } catch (error) {
                  console.error(`Error processing ${fileName}:`, error);
                  alert(`An error occurred while processing ${fileName}. Check the console for details.`);
                  // Optionally, break or decide how to handle errors for multiple files
                }
              } else {
                alert("Unsupported file type. Please upload a PDF file.");
                e.target.value = null; 
                // if (h1Title) h1Title.textContent = originalPageTitle; // No longer needed
                break; 
              }
            }
          } finally {
            updateAndSaveData(); // <<< KEY FIX: Update display and save data after all files are processed
            // if (h1Title) h1Title.textContent = originalPageTitle; // No longer needed
            hideProcessingBar(); // Hide progress bar when all processing is done or an error broke the loop
            e.target.value = null; // Clear the file input to allow re-uploading the same file(s)
          }
        });
      }

      // --- Function to process PDF files (placeholder for OpenAI API call) ---
      async function handlePdfFile(file) {
        const fileName = file.name;
        console.log(`Attempting to process PDF: ${fileName}`);

        // Store old keys this file affected, to ensure they are rebuilt correctly
        const oldKeysForThisFile = fileDataKeysMap[fileName] ? new Set(fileDataKeysMap[fileName]) : new Set();
        
        // First, remove any existing transactions from this file to prevent duplication if re-uploaded
        globalAllTransactions = globalAllTransactions.filter(tx => tx.sourceFile !== fileName);
        // Note: At this point, dailyActivity might be stale for oldKeysForThisFile until rebuild happens.

        try {
          const base64File = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result); 
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file); 
          });

          const pureBase64 = base64File.substring(base64File.indexOf(',') + 1);
          
          const extractedData = await callGeminiPdfParser(pureBase64, fileName);

          let newContributedDailyKeys = new Set();

          if (!extractedData || !extractedData.transactions || !Array.isArray(extractedData.transactions)) {
            console.error('No transactions found or invalid format from parser for file:', fileName);
            addFileToHistory(fileName, []); // Update history with no keys for this file
            // Rebuild any dates this file previously affected to clear its old contributions
            if (oldKeysForThisFile.size > 0) {
                rebuildDailyActivityForDates(Array.from(oldKeysForThisFile));
            }
            return; 
          }

          const isDCFile = fileName.toUpperCase().startsWith("DC"); // Determine once

          if (extractedData.transactions.length === 0) {
            console.log(`No transactions extracted from ${fileName}.`);
            addFileToHistory(fileName, []); 
          } else {
            extractedData.transactions.forEach(transaction => {
              const transactionDate = transaction.date; 
              
              if (!transactionDate || !/^\d{4}-\d{2}-\d{2}$/.test(transactionDate)) {
                console.warn(`Skipping transaction in ${fileName} due to missing or invalid date:`, transaction);
                return; 
              }
              
              const amount = parseFloat(transaction.amount);
              if (isNaN(amount)) {
                console.warn(`Skipping transaction in ${fileName} due to invalid amount:`, transaction);
                return; 
              }
              newContributedDailyKeys.add(transactionDate);

              globalAllTransactions.push({
                date: transactionDate,
                description: transaction.description,
                amount: amount, 
                category: transaction.category || (isDCFile ? 'Income' : 'N/A'),
                sourceFile: fileName
              });
            });
            addFileToHistory(fileName, Array.from(newContributedDailyKeys));
          }

          // Combine old and new keys to ensure all affected dates are rebuilt
          const allAffectedKeys = new Set([...oldKeysForThisFile, ...newContributedDailyKeys]);
          if (allAffectedKeys.size > 0) {
            rebuildDailyActivityForDates(Array.from(allAffectedKeys));
          }

        } catch (error) {
          console.error(`Error in handlePdfFile for ${fileName}:`, error);
          // If an error occurred after removing old transactions, 
          // ensure dailyActivity is rebuilt for those old keys based on the (now filtered) globalAllTransactions
          if (oldKeysForThisFile.size > 0) {
             rebuildDailyActivityForDates(Array.from(oldKeysForThisFile));
          }
          throw error; 
        }
      }

      async function callGeminiPdfParser(base64Pdf, fileNameForContext) {
        console.log(`Sending ${fileNameForContext} to Google Gemini API for parsing...`);
        if (!GEMINI_API_KEY) {
            throw new Error("Gemini API key is not loaded. Please check config.js.");
        }
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

        let systemInstructionText = `You are a data extraction AI. You will receive a PDF bank statement. Your task is to:
1. Identify all individual financial transaction lines. Focus on itemized entries, not summary totals unless they are the only source for a specific transaction type.
2. For each transaction found, extract the date, description, and amount.
3. For each transaction identified as an expense (typically a positive amount based on the rules below), categorize it into one of the following: 'Groceries', 'Food Delivery/Restaurant', 'Gas', 'Misc', 'Other'. If a transaction is a credit/payment (negative amount), the category field can be null or an empty string.

Return a single JSON object: \`{ "transactions": [ { "date": "YYYY-MM-DD", "description": "...", "amount": number, "category": "string_or_null" }, ... ] }\`.

CRITICAL RULES for 'amount':
  - Charges/Debits/Purchases/Expenses/Withdrawals are POSITIVE numbers (e.g., 100.00).
  - Payments/Credits/Deposits/Income are NEGATIVE numbers (e.g., -50.00).
  - Examine transaction descriptions for keywords like 'Purchase', 'Fee', 'Withdrawal' (positive) or 'Payment', 'Deposit', 'Credit', 'Income' (negative).
  - If the PDF text clearly shows 'Debit' and 'Credit' columns, amounts in a 'Debit' column are positive, and amounts in a 'Credit' column are negative.

For 'date': Use 'YYYY-MM-DD'. If the full date isn't on the transaction line, infer the year and month from the overall statement period (often found in the filename or at the top/bottom of the PDF text). If day is missing, use '01'.
For 'description': Capture the full transaction detail as presented on the statement.

Category definitions for expenses:
- 'Groceries': Purchases from supermarkets, grocery stores (e.g., Walmart, Kroger, Trader Joe's, ALDI, Whole Foods).
- 'Food Delivery/Restaurant': Expenses at restaurants, cafes, fast food establishments, and food delivery services (e.g., Doordash, Uber Eats, Grubhub, Starbucks, McDonald's, local restaurants).
- 'Gas': Fuel purchases from gas stations (e.g., Shell, Exxon, BP, Chevron, local gas stations).
- 'Misc': This category is for all other expenses that do not clearly fall into 'Groceries', 'Food Delivery/Restaurant', or 'Gas'. This includes but is not limited to: utility payments (electricity, water, internet, phone), subscriptions (Netflix, Spotify, gym), shopping (clothing, electronics, household goods), entertainment (movies, concerts), travel costs (flights, hotels, not gas), medical co-pays, insurance premiums, rent/mortgage payments, loan repayments, childcare fees, property taxes. If an expense doesn't fit the specific categories above, it should be classified as 'Misc'.
- 'Other': Use this category sparingly for expenses that are highly unusual or cannot be classified even under the broad 'Misc' category. For most unclassified expenses, 'Misc' is preferred. This could also be used if an item is clearly an expense but its nature is completely indeterminable.

The response MUST be only the valid JSON object, with no extra text, explanations, or markdown formatting.`;

        // Check if the filename starts with "DC"
        if (fileNameForContext && fileNameForContext.toUpperCase().startsWith("DC")) {
          // Modify system instruction for "DC" files to only extract income (payments/credits)
          // and not categorize expenses.
          systemInstructionText = `You are a data extraction AI. You will receive a PDF bank statement from a file named '${fileNameForContext}'.
This file is specifically for income. Your task is to:
1. Identify all individual financial transaction lines that represent INCOME or CREDITS to the account.
2. For each such transaction found, extract the date, description, and amount.
3. IGNORE ALL EXPENSES/CHARGES/DEBITS. Only process income/credits.

Return a single JSON object: \`{ "transactions": [ { "date": "YYYY-MM-DD", "description": "...", "amount": number, "category": null }, ... ] }\`.

CRITICAL RULES for 'amount':
  - Payments/Credits/Deposits/Income are NEGATIVE numbers (e.g., -50.00).
  - ALL OTHER TRANSACTION TYPES (CHARGES/DEBITS/EXPENSES) SHOULD BE IGNORED.

For 'date': Use 'YYYY-MM-DD'. If the full date isn't on the transaction line, infer the year and month from the overall statement period. If day is missing, use '01'.
For 'description': Capture the full transaction detail.
The 'category' field should always be null for these income transactions.

The response MUST be only the valid JSON object, with no extra text, explanations, or markdown formatting.`;
        }


        const userPromptText = `Please analyze the attached PDF bank statement named '${fileNameForContext}' and extract all financial transactions according to the detailed system instructions. Pay utmost attention to correctly identifying and signing the 'amount' for each transaction (positive for charges, negative for payments/credits) and categorizing expenses.`;

        const payload = {
          contents: [
            {
              parts: [
                { text: userPromptText },
                {
                  inline_data: {
                    mime_type: "application/pdf",
                    data: base64Pdf
                  }
                }
              ]
            }
          ],
          system_instruction: {
            parts: [
              { text: systemInstructionText }
            ]
          },
          generationConfig: {
            response_mime_type: "application/json",
            temperature: 0.2 
          }
        };

        try {
          const response = await fetch(API_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorBody = await response.json().catch(() => response.text()); // Try to parse as JSON, fallback to text
            console.error("Gemini API Error Response:", errorBody);
            const errorMessage = errorBody.error && errorBody.error.message ? errorBody.error.message : JSON.stringify(errorBody);
            throw new Error(`Gemini API request failed with status ${response.status}: ${response.statusText}. Details: ${errorMessage}`);
          }

          const data = await response.json();
          console.log("Gemini API Raw Response:", data);

          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text) {
            const jsonString = data.candidates[0].content.parts[0].text;
            console.log("Gemini API JSON String Content:", jsonString);
            try {
                return JSON.parse(jsonString);
            } catch (parseError) {
                console.error("Failed to parse JSON from Gemini response:", parseError, "Raw content:", jsonString);
                // Check if it might already be an object (though API docs say it's a string with response_mime_type: "application/json")
                if (typeof jsonString === 'object') return jsonString;
                throw new Error("Failed to parse JSON from Gemini API response. Check console for raw output.");
            }
          } else {
            console.error("Unexpected Gemini API response structure:", data);
            throw new Error("Unexpected response structure from Gemini API. No valid content found.");
          }
        } catch (error) {
          console.error("Error calling Gemini API:", error);
          // Display a more user-friendly error message on the page
          const errorDisplay = document.getElementById('apiErrorDisplay'); // Assuming you add such an element
          if (errorDisplay) {
            errorDisplay.textContent = `Error communicating with the AI: ${error.message}. Please check your API key and network connection.`;
          }
          return { transactions: [], summary: "Error during parsing." }; // Return empty on error
        }
      }
    </script>
  </div>
</body>
</html>